var searchIndex = JSON.parse('{\
"itoa":{"doc":"This crate provides fast functions for printing integer…","i":[[3,"Buffer","itoa","A safe API for formatting integers to text.",null,null],[5,"write","","Write integer to an `io::Write`.",null,[[["write",8],["integer",8]],["result",6]]],[5,"fmt","","Write integer to an `fmt::Write`.",null,[[["write",8],["integer",8]],["result",6]]],[8,"Integer","","An integer that can be formatted by `itoa::write` and…",null,null],[11,"new","","This is a cheap operation; you don\'t need to worry about…",0,[[],["buffer",3]]],[11,"format","","Print an integer into this buffer and return a reference…",0,[[["integer",8]]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"clone","","",0,[[]]],[11,"default","","",0,[[],["buffer",3]]]],"p":[[3,"Buffer"]]},\
"lexpr":{"doc":"This crate provides facilities for parsing, printing and…","i":[[3,"Parser","lexpr","Parser for the S-expression text representation.",null,null],[3,"Printer","","A printer for S-expression values.",null,null],[3,"Datum","","Combines an S-expression value with location information.",null,null],[3,"Cons","","A Lisp \\\"cons cell\\\".",null,null],[3,"Number","","Represents an S-expression number, whether integer or…",null,null],[4,"Value","","Represents an S-expression value.",null,null],[13,"Nil","","The special \\\"nil\\\" value.",0,null],[13,"Null","","The empty list.",0,null],[13,"Bool","","A boolean value.",0,null],[13,"Number","","A number.",0,null],[13,"Char","","A character.",0,null],[13,"String","","A string.",0,null],[13,"Symbol","","A symbol.",0,null],[13,"Keyword","","A keyword.",0,null],[13,"Bytes","","A byte vector.",0,null],[13,"Cons","","Represents a Lisp \\\"cons cell\\\".",0,null],[13,"Vector","","A Lisp vector.",0,null],[5,"from_reader","","Parse a value from an IO stream of S-expressions, using…",null,[[],[["value",4],["result",6]]]],[5,"from_reader_custom","","Parse a value from an IO stream containing a single…",null,[[["options",3]],[["value",4],["result",6]]]],[5,"from_slice","","Parse a value from bytes representing a single…",null,[[],[["value",4],["result",6]]]],[5,"from_slice_custom","","Parse a value from bytes representing a single S-expression.",null,[[["options",3]],[["value",4],["result",6]]]],[5,"from_str","","Parse a value from a string slice representing a single…",null,[[],[["value",4],["result",6]]]],[5,"from_str_custom","","Parse a value from a string slice representing a single…",null,[[["options",3]],[["value",4],["result",6]]]],[5,"to_string","","Serialize the given value an S-expression string, using…",null,[[["value",4]],[["result",6],["string",3]]]],[5,"to_string_custom","","Serialize the given value an S-expression string.",null,[[["value",4],["options",3]],[["result",6],["string",3]]]],[5,"to_vec","","Serialize the given value as byte vector containing…",null,[[["value",4]],[["result",6],["vec",3]]]],[5,"to_vec_custom","","Serialize the given value as byte vector containing…",null,[[["value",4],["options",3]],[["result",6],["vec",3]]]],[5,"to_writer","","Serialize the given value value as S-expression text into…",null,[[["write",8],["value",4]],["result",6]]],[5,"to_writer_custom","","Serialize the given value value as S-expression text into…",null,[[["write",8],["value",4],["options",3]],["result",6]]],[0,"cons","","List \\\"cons cell\\\" data type and accompanying iterator types.",null,null],[3,"Cons","lexpr::cons","A Lisp \\\"cons cell\\\".",null,null],[3,"Iter","","An iterator over a chain of cons cells.",null,null],[3,"IntoIter","","An iterator consuming a chain of cons cells.",null,null],[3,"ListIter","","An iterator yielding the `car` field of a chain of cons…",null,null],[11,"new","","Constructs a new cons cell from two values.",1,[[]]],[11,"car","","Returns a reference to the value in the `car` field.",1,[[],["value",4]]],[11,"car_mut","","Returns a mutable reference to the value in the `car` field.",1,[[],["value",4]]],[11,"set_car","","Sets the `car` field.",1,[[]]],[11,"cdr","","Returns a reference to the value in the `cdr` field.",1,[[],["value",4]]],[11,"cdr_mut","","Returns a mutable reference to the value in the `cdr` field.",1,[[],["value",4]]],[11,"set_cdr","","Sets the `cdr` field.",1,[[]]],[11,"as_pair","","Returns references to the values in the `car` and `cdr`…",1,[[]]],[11,"into_pair","","Converts `self` into a pair of values without cloning.",1,[[]]],[11,"iter","","Obtains an iterator yielding references to all the cons…",1,[[],["iter",3]]],[11,"into_vec","","Converts `self` into a vector without cloning the elements.",1,[[]]],[11,"to_vec","","Retrieves a vector, cloning the values.",1,[[]]],[11,"to_ref_vec","","Retrieves a vector, taking references to the values.",1,[[]]],[11,"list_iter","","Returns an iterator that returns each element (`car`…",1,[[],["listiter",3]]],[11,"peek","","Returns the current cons cell, without advancing the…",2,[[],[["cons",3],["option",4]]]],[11,"peek","","Returns the current cons cell, without advancing the…",3,[[],[["cons",3],["option",4]]]],[11,"peek_mut","","Returns a mutable reference to the current cons cell,…",3,[[],[["option",4],["cons",3]]]],[11,"is_empty","","Returns true when the iterator is completely exhausted.",4,[[]]],[11,"peek","","Returns a peek at the value that would be returned by a…",4,[[],[["value",4],["option",4]]]],[0,"datum","lexpr","S-expression values including source location.",null,null],[3,"Datum","lexpr::datum","Combines an S-expression value with location information.",null,null],[3,"Ref","","A reference to a value and corresponding location…",null,null],[3,"Span","","The start and end for a span of text.",null,null],[3,"VectorIter","","An iterator over the elements",null,null],[3,"ListIter","","An iterator yielding the `car` field of a chain of cons…",null,null],[5,"from_reader_custom","","Parse a datum from an IO stream containing a single…",null,[[["options",3]],[["datum",3],["result",6]]]],[5,"from_reader","","Parse a datum from an IO stream of S-expressions, using…",null,[[],[["datum",3],["result",6]]]],[5,"from_reader_elisp","","Parse a datum from an IO stream of S-expressions, using…",null,[[],[["datum",3],["result",6]]]],[5,"from_slice_custom","","Parse a datum from bytes representing a single S-expression.",null,[[["options",3]],[["datum",3],["result",6]]]],[5,"from_slice","","Parse a datum from bytes representing a single…",null,[[],[["datum",3],["result",6]]]],[5,"from_slice_elisp","","Parse a datum from bytes representing a single…",null,[[],[["datum",3],["result",6]]]],[5,"from_str_custom","","Parse a datum from a string slice representing a single…",null,[[["options",3]],[["datum",3],["result",6]]]],[5,"from_str","","Parse a datum from a string slice representing a single…",null,[[],[["datum",3],["result",6]]]],[5,"from_str_elisp","","Parse a datum from a string slice representing a single…",null,[[],[["datum",3],["result",6]]]],[11,"value","","Returns a reference to the contained value.",5,[[],["value",4]]],[11,"span","","Returns the span for the compelete value.",5,[[],["span",3]]],[11,"as_ref","","Returns a reference to the datum.",5,[[],["ref",3]]],[11,"list_iter","","Returns an iterator over the elements of a list.",5,[[],[["option",4],["listiter",3]]]],[11,"vector_iter","","Returns an iterator over the elements of a vector.",5,[[],[["vectoriter",3],["option",4]]]],[11,"span","","Returns the span of the referenced value.",6,[[],["span",3]]],[11,"value","","Returns a reference to the contained value.",6,[[],["value",4]]],[11,"list_iter","","If the value referenced is not either a cons cell or…",6,[[],[["option",4],["listiter",3]]]],[11,"vector_iter","","Returns an iterator over the elements of a vector.",6,[[],[["vectoriter",3],["option",4]]]],[11,"as_pair","","Returns a pair of references to the fields of a cons cell.",6,[[],["option",4]]],[11,"start","","Get the starting line/column in the source file for this…",7,[[],["position",3]]],[11,"end","","Get the ending line/column in the source file for this span.",7,[[],["position",3]]],[11,"is_empty","","Returns true when the iterator is completely exhausted.",8,[[]]],[11,"peek","","Returns a peek at the value that would be returned by a…",8,[[],[["ref",3],["option",4]]]],[0,"number","lexpr","Dynamically typed number type.",null,null],[3,"Number","lexpr::number","Represents an S-expression number, whether integer or…",null,null],[8,"Visitor","","Trait to access the value stored in `Number`.",null,null],[16,"Value","","The return type of the visitor methods.",9,null],[16,"Error","","The error type of the visitor methods.",9,null],[10,"error","","Construct an error given a message.",9,[[["string",3],["into",8]]]],[10,"visit_u64","","The stored value is a `u64`.",9,[[],["result",4]]],[10,"visit_i64","","The stored value is an `i64`.",9,[[],["result",4]]],[10,"visit_f64","","The stored value is `f64`.",9,[[],["result",4]]],[11,"is_i64","","Returns true if the `Number` is an integer between…",10,[[]]],[11,"is_u64","","Returns true if the `Number` is an integer between zero…",10,[[]]],[11,"is_f64","","Returns true if the `Number` can be represented by f64.",10,[[]]],[11,"as_i64","","If the `Number` is an integer, represent it as i64 if…",10,[[],["option",4]]],[11,"as_u64","","If the `Number` is an integer, represent it as u64 if…",10,[[],["option",4]]],[11,"as_f64","","Represents the number as f64 if possible. Returns None…",10,[[],["option",4]]],[11,"from_f64","","Converts a finite `f64` to a `Number`. Infinite or NaN…",10,[[],[["option",4],["number",3]]]],[11,"visit","","Dispatch based on the type of the contained value.",10,[[],["result",4]]],[0,"parse","lexpr","S-expression parser and options.",null,null],[3,"IoRead","lexpr::parse","S-expression input source that reads from a std::io input…",null,null],[3,"Position","","A location in the parsed text.",null,null],[3,"SliceRead","","S-expression input source that reads from a slice of bytes.",null,null],[3,"StrRead","","S-expression input source that reads from a UTF-8 string.",null,null],[3,"Error","","This type represents the possible errors when parsing…",null,null],[3,"Parser","","Parser for the S-expression text representation.",null,null],[3,"Options","","Various options to influence parser behavior.",null,null],[3,"ValueIter","","Iterator over the values producedd by a parser.",null,null],[3,"DatumIter","","Iterator over the datums producedd by a parser.",null,null],[4,"CharSyntax","","Indicates the syntax for characters.",null,null],[13,"R6RS","","Syntax as specified in R6RS.",11,null],[13,"Elisp","","Emacs Lisp syntax.",11,null],[4,"KeywordSyntax","","Indicates a syntax of keywords.",null,null],[13,"ColonPrefix","","Parse identifiers starting with a colon as keywords.",12,null],[13,"ColonPostfix","","Parse identifiers ending with a colon as keywords.",12,null],[13,"Octothorpe","","Parse identifiers prefixed with `#:` as keywords.",12,null],[4,"StringSyntax","","Indicates the syntax for strings.",null,null],[13,"R6RS","","Syntax as specified the R6RS.",13,null],[13,"Elisp","","Emacs Lisp syntax.",13,null],[4,"NilSymbol","","Defines the treatment of the symbol `nil`.",null,null],[13,"EmptyList","","Parse `nil` like as the empty list. This the behavior of…",14,null],[13,"Default","","Parse `nil` as a regular symbol. This is the behavior…",14,null],[13,"Special","","Parse `nil` as a special value. This allows treating the…",14,null],[4,"TSymbol","","Defines the treatment of the symbol `t`.",null,null],[13,"True","","Parse `t` as the boolean true value.",15,null],[13,"Default","","Parse `t` as a regular symbol.",15,null],[4,"Brackets","","Defines the treatment of brackets.",null,null],[13,"List","","Brackets are synonymous with regular parentheses, and…",16,null],[13,"Vector","","Brackets indicate a vector, like in Emacs Lisp.",16,null],[5,"from_reader_custom","","Parse a value from an IO stream containing a single…",null,[[["options",3]],[["value",4],["result",6]]]],[5,"from_reader","","Parse a value from an IO stream of S-expressions, using…",null,[[],[["value",4],["result",6]]]],[5,"from_reader_elisp","","Parse a value from an IO stream of S-expressions, using…",null,[[],[["value",4],["result",6]]]],[5,"from_slice_custom","","Parse a value from bytes representing a single S-expression.",null,[[["options",3]],[["value",4],["result",6]]]],[5,"from_slice","","Parse a value from bytes representing a single…",null,[[],[["value",4],["result",6]]]],[5,"from_slice_elisp","","Parse a value from bytes representing a single…",null,[[],[["value",4],["result",6]]]],[5,"from_str_custom","","Parse a value from a string slice representing a single…",null,[[["options",3]],[["value",4],["result",6]]]],[5,"from_str","","Parse a value from a string slice representing a single…",null,[[],[["value",4],["result",6]]]],[5,"from_str_elisp","","Parse a value from a string slice representing a single…",null,[[],[["value",4],["result",6]]]],[0,"error","","When parsing S-expressions goes wrong.",null,null],[3,"Error","lexpr::parse::error","This type represents the possible errors when parsing…",null,null],[3,"Location","","Location of a parse error.",null,null],[4,"Category","","Categorizes the cause of a `lexpr::parse::Error`.",null,null],[13,"Io","","The error was caused by a failure to read or bytes from an…",17,null],[13,"Syntax","","The error was caused by input that was not a syntactically…",17,null],[13,"Eof","","The error was caused by prematurely reaching the end of…",17,null],[6,"Result","","Alias for a `Result` with the error type `lexpr::Error`.",null,null],[11,"line","","One-based line number at which the error was detected.",18,[[]]],[11,"column","","One-based column number at which the error was detected.",18,[[]]],[11,"location","","Location of the error in the input stream.",19,[[],[["location",3],["option",4]]]],[11,"classify","","Categorizes the cause of this error.",19,[[],["category",4]]],[11,"is_io","","Returns true if this error was caused by a failure to read…",19,[[]]],[11,"is_syntax","","Returns true if this error was caused by input that was…",19,[[]]],[11,"is_eof","","Returns true if this error was caused by prematurely…",19,[[]]],[11,"line","lexpr::parse","Returns the 1-based line number.",20,[[]]],[11,"column","","Returns the column.",20,[[]]],[11,"new","","Create a S-expression input source to read from a std::io…",21,[[]]],[11,"new","","Create a S-expression input source to read from a slice of…",22,[[]]],[11,"new","","Create a S-expression input source to read from a UTF-8…",23,[[]]],[6,"Result","","Alias for a `Result` with the error type `lexpr::Error`.",null,null],[8,"Read","","Trait used by the parser for iterating over input.",null,null],[11,"parse_elisp_char","","Parses an Emacs Lisp character constant.",24,[[["vec",3]],["result",6]]],[11,"new","","Construct an empty set of options.",25,[[]]],[11,"elisp","","Construct a set of options suitable for parsing Emacs Lisp.",25,[[]]],[11,"with_keyword_syntax","","Add `syntax` to the recognized keyword syntaxes.",25,[[["keywordsyntax",4]]]],[11,"with_keyword_syntaxes","","Set the recognized keyword syntaxes.",25,[[]]],[11,"with_nil_symbol","","Choose how to parse the `nil` symbol.",25,[[["nilsymbol",4]]]],[11,"with_t_symbol","","Choose how to parse the `t` symbol.",25,[[["tsymbol",4]]]],[11,"with_brackets","","Choose how to handle brackets.",25,[[["brackets",4]]]],[11,"with_string_syntax","","Choose the accepted string syntax.",25,[[["stringsyntax",4]]]],[11,"with_char_syntax","","Choose the accepted character syntax.",25,[[["charsyntax",4]]]],[11,"keyword_syntax","","Check wether a keyword syntax is enabled.",25,[[["keywordsyntax",4]]]],[11,"nil_symbol","","Query the way the `nil` symbol is handled.",25,[[],["nilsymbol",4]]],[11,"t_symbol","","Query the way the `t` symbol is handled.",25,[[],["tsymbol",4]]],[11,"brackets","","Query the way brackets are handled.",25,[[],["brackets",4]]],[11,"string_syntax","","Query the accepted string syntax.",25,[[],["stringsyntax",4]]],[11,"char_syntax","","Query the accepted character syntax.",25,[[],["charsyntax",4]]],[11,"new","","Create an S-expression parser from one of the possible…",26,[[]]],[11,"with_options","","Create a customized S-expression parser parser from one of…",26,[[["options",3]]]],[11,"from_reader","","Creates an S-expression parser from an `io::Read`.",26,[[]]],[11,"from_reader_custom","","Creates an S-expression parser from an `io::Read`.",26,[[["options",3]]]],[11,"from_slice","","Creates an S-expression parser from a `&[u8]`.",26,[[]]],[11,"from_slice_custom","","Creates an S-expression parser from a `&[u8]`.",26,[[["options",3]]]],[11,"from_str","","Creates a S-expression parser from a `&str`.",26,[[]]],[11,"from_str_custom","","Creates a S-expression parser from a `&str`.",26,[[["options",3]]]],[11,"expect_end","","Expect the end of input.",26,[[],["result",6]]],[11,"end","","Expect the end of input.",26,[[],["result",6]]],[11,"value_iter","","Obtain an iterator over the values produced by the parser.",26,[[],["valueiter",3]]],[11,"datum_iter","","Obtain an iterator over the values produced by the parser,…",26,[[],["datumiter",3]]],[11,"parse_value","","Parse a single S-expression from the input source.",26,[[],[["value",4],["result",6]]]],[11,"expect_value","","Parse a single S-expression from the input source.",26,[[],[["value",4],["result",6]]]],[11,"next_value","","Parse an S-expression, returning `None` on end-of-input.",26,[[],[["result",6],["option",4]]]],[11,"parse","","Parse a single S-expression from the input source.",26,[[],[["result",6],["option",4]]]],[11,"expect_datum","","Parse a single S-expression including location…",26,[[],[["datum",3],["result",6]]]],[11,"next_datum","","Parse a single S-expression including location information.",26,[[],[["option",4],["result",6]]]],[0,"print","lexpr","Converting S-expression values into text.",null,null],[3,"Options","lexpr::print","Options for printing S-expressions.",null,null],[3,"DefaultFormatter","","This structure compacts a S-expression value on a single…",null,null],[3,"CustomizedFormatter","","A formatter which can be tuned with regards to…",null,null],[3,"Printer","","A printer for S-expression values.",null,null],[4,"CharSyntax","","Indicates the syntax for characters.",null,null],[13,"R6RS","","Syntax as specified in R6RS.",11,null],[13,"Elisp","","Emacs Lisp syntax.",11,null],[4,"KeywordSyntax","","Indicates a syntax of keywords.",null,null],[13,"ColonPrefix","","Parse identifiers starting with a colon as keywords.",12,null],[13,"ColonPostfix","","Parse identifiers ending with a colon as keywords.",12,null],[13,"Octothorpe","","Parse identifiers prefixed with `#:` as keywords.",12,null],[4,"StringSyntax","","Indicates the syntax for strings.",null,null],[13,"R6RS","","Syntax as specified the R6RS.",13,null],[13,"Elisp","","Emacs Lisp syntax.",13,null],[4,"NilSyntax","","How to print the special nil value.",null,null],[13,"Symbol","","Output a `nil` symbol.",27,null],[13,"Token","","Output the `#nil` token.",27,null],[13,"EmptyList","","Output the empty list.",27,null],[13,"False","","Output a boolean false value.",27,null],[4,"BoolSyntax","","How to print boolean values.",null,null],[13,"Token","","Use the Scheme tokens `#t` and `#f`",28,null],[13,"Symbol","","Use symbols `nil` and `t`.",28,null],[4,"VectorSyntax","","How to print vectors.",null,null],[13,"Octothorpe","","Use Scheme notation, i.e. `#(...)`.",29,null],[13,"Brackets","","Use brackets, as used in Emacs Lisp.",29,null],[4,"BytesSyntax","","How to print byte vectors.",null,null],[13,"R6RS","","Use R6RS byte vector syntax, e.g. `#vu8(1 2 3)`.",30,null],[13,"R7RS","","Use R7RS byte vector syntax, e.g. `#u8(1 2 3)`.",30,null],[13,"Elisp","","Use Emacs Lisp unibyte string syntax, e.g. `\\\"\\\\001\\\\002\\\\003\\\"`.",30,null],[4,"CharEscape","","Represents a character escape code in a type-safe manner.",null,null],[13,"Quote","","An escaped quote `\\\"`",31,null],[13,"ReverseSolidus","","An escaped reverse solidus `\\\\`",31,null],[13,"Alert","","Alert, also known as \\\"bell\\\" (usually escaped as `\\\\a`)",31,null],[13,"Backspace","","An escaped backspace character (usually escaped as `\\\\b`)",31,null],[13,"LineFeed","","An escaped line feed character (usually escaped as `\\\\n`)",31,null],[13,"CarriageReturn","","An escaped carriage return character (usually escaped as…",31,null],[13,"Tab","","An escaped tab character (usually escaped as `\\\\t`)",31,null],[13,"AsciiControl","","An escaped ASCII plane control character (usually escaped…",31,null],[4,"VectorType","","Different vector types",null,null],[13,"Generic","","Generic vector, containing elements of any type.",32,null],[13,"Byte","","Byte vector, containing only byte (octet) values.",32,null],[5,"to_writer","","Serialize the given value value as S-expression text into…",null,[[["write",8],["value",4]],["result",6]]],[5,"to_writer_custom","","Serialize the given value value as S-expression text into…",null,[[["write",8],["value",4],["options",3]],["result",6]]],[5,"to_vec","","Serialize the given value as byte vector containing…",null,[[["value",4]],[["result",6],["vec",3]]]],[5,"to_vec_custom","","Serialize the given value as byte vector containing…",null,[[["value",4],["options",3]],[["result",6],["vec",3]]]],[5,"to_string","","Serialize the given value an S-expression string, using…",null,[[["value",4]],[["result",6],["string",3]]]],[5,"to_string_custom","","Serialize the given value an S-expression string.",null,[[["value",4],["options",3]],[["result",6],["string",3]]]],[8,"Formatter","","This trait abstracts away serializing the S-expression…",null,null],[11,"write_nil","","Writes a representation of the special nil value to the…",33,[[],["result",6]]],[11,"write_null","","Writes a representation of the special nil value to the…",33,[[],["result",6]]],[11,"write_bool","","Writes a representation of a boolean value to the…",33,[[],["result",6]]],[11,"write_number","","Writes an integer value like `-123` to the specified writer.",33,[[["number",3]],["result",6]]],[11,"write_char","","Writes a charactor to the specified writer.",33,[[],["result",6]]],[11,"begin_string","","Called before each series of `write_string_fragment` and…",33,[[],["result",6]]],[11,"end_string","","Called after each series of `write_string_fragment` and…",33,[[],["result",6]]],[11,"write_string_fragment","","Writes a string fragment that doesn\'t need any escaping to…",33,[[],["result",6]]],[11,"write_char_escape","","Writes a character escape code to the specified writer.",33,[[["charescape",4]],["result",6]]],[11,"write_symbol","","Writes a symbol to the specified writer.",33,[[],["result",6]]],[11,"write_keyword","","Writes a keyword to the specified writer.",33,[[],["result",6]]],[11,"write_bytes","","Writes a byte vector to the specified writer.",33,[[],["result",6]]],[11,"begin_list","","Called before any list elements. Writes a `(` to the…",33,[[],["result",6]]],[11,"end_list","","Called after all list elements have been written. Writes a…",33,[[],["result",6]]],[11,"begin_seq_element","","Called before starting to write a list or vector element.…",33,[[],["result",6]]],[11,"end_seq_element","","Called after every list or vector element.",33,[[],["result",6]]],[11,"begin_vector","","Called before any vector elements. Will write `#(` for…",33,[[["vectortype",4]],["result",6]]],[11,"end_vector","","Called after all vector elements have been written. Writes…",33,[[],["result",6]]],[11,"write_dot","","Called before writing the tail of an improper list, or…",33,[[],["result",6]]],[11,"elisp","","Construct parser options suitable for printing Emacs Lisp.",34,[[]]],[11,"with_keyword_syntax","","Set the syntax to use for printing keywords.",34,[[["keywordsyntax",4]]]],[11,"with_nil_syntax","","Set the syntax to use to print the special nil value.",34,[[["nilsyntax",4]]]],[11,"with_bool_syntax","","Set the syntax to use to print boolean values.",34,[[["boolsyntax",4]]]],[11,"with_vector_syntax","","Set the syntax for printing vectors.",34,[[["vectorsyntax",4]]]],[11,"with_bytes_syntax","","Set the syntax to use for printing byte vectors.",34,[[["bytessyntax",4]]]],[11,"with_string_syntax","","Set the syntax used for printing strings.",34,[[["stringsyntax",4]]]],[11,"with_char_syntax","","Set the syntax used for printing characters.",34,[[["charsyntax",4]]]],[11,"with_options","","Construct an S-expression printer tuned given the…",35,[[["options",3]]]],[11,"with_formatter","","Creates a new S-expression printer whose output will be…",35,[[]]],[11,"into_inner","","Unwrap the `Writer` from the `Printer`.",35,[[]]],[11,"print","","Output the representation of the specified value to the…",35,[[["value",4]],["result",6]]],[11,"new","","Creates a new S-expression printer.",35,[[]]],[0,"value","lexpr","The Value enum, a dynamically typed way of representing…",null,null],[4,"Value","lexpr::value","Represents an S-expression value.",null,null],[13,"Nil","","The special \\\"nil\\\" value.",0,null],[13,"Null","","The empty list.",0,null],[13,"Bool","","A boolean value.",0,null],[13,"Number","","A number.",0,null],[13,"Char","","A character.",0,null],[13,"String","","A string.",0,null],[13,"Symbol","","A symbol.",0,null],[13,"Keyword","","A keyword.",0,null],[13,"Bytes","","A byte vector.",0,null],[13,"Cons","","Represents a Lisp \\\"cons cell\\\".",0,null],[13,"Vector","","A Lisp vector.",0,null],[8,"Index","","A type that can be used to index into a `lexpr::Value`.",null,null],[11,"symbol","","Construct a symbol, given its name.",0,[[]]],[11,"keyword","","Construct a keyword, given its name.",0,[[]]],[11,"string","","Construct a string.",0,[[]]],[11,"bytes","","Construct a byte vector.",0,[[]]],[11,"cons","","Create a cons cell given its `car` and `cdr` fields.",0,[[]]],[11,"list","","Create a list value from elements convertible into `Value`.",0,[[]]],[11,"is_list","","Returns true if the value is a (proper) list.",0,[[]]],[11,"is_dotted_list","","Returns true if the value is a dotted (improper) list.",0,[[]]],[11,"append","","Create a list value from elements convertible into…",0,[[]]],[11,"vector","","Create a vector value from elements convertible into…",0,[[]]],[11,"is_string","","Returns true if the value is a String. Returns false…",0,[[]]],[11,"as_str","","If the value is a String, returns the associated str.…",0,[[],["option",4]]],[11,"is_symbol","","Returns true if the value is a symbol. Returns false…",0,[[]]],[11,"as_symbol","","If the value is a symbol, returns the associated str.…",0,[[],["option",4]]],[11,"is_keyword","","Returns true if the value is a keyword. Returns false…",0,[[]]],[11,"as_keyword","","If the value is a keyword, returns the associated str.…",0,[[],["option",4]]],[11,"as_name","","Get the name of a symbol or keyword, or the value of a…",0,[[],["option",4]]],[11,"is_bytes","","Returns true if the value is a byte vector. Returns false…",0,[[]]],[11,"as_bytes","","If the value is a byte vector, returns the associated byte…",0,[[],["option",4]]],[11,"is_number","","Return `true` if the value is a number.",0,[[]]],[11,"as_number","","For numbers, return a reference to them. For other values,…",0,[[],[["option",4],["number",3]]]],[11,"is_i64","","Returns true if the value is an integer between `i64::MIN`…",0,[[]]],[11,"is_u64","","Returns true if the value is an integer between zero and…",0,[[]]],[11,"is_f64","","Returns true if the value is a number that can be…",0,[[]]],[11,"as_i64","","If the value is an integer, represent it as i64 if…",0,[[],["option",4]]],[11,"as_u64","","If the value is an integer, represent it as u64 if…",0,[[],["option",4]]],[11,"as_f64","","If the value is a number, represent it as f64 if possible.…",0,[[],["option",4]]],[11,"is_boolean","","Returns true if the value is a Boolean. Returns false…",0,[[]]],[11,"as_bool","","If the value is a `Boolean`, returns the associated bool.…",0,[[],["option",4]]],[11,"is_char","","Returns true if the value is a character. Returns false…",0,[[]]],[11,"as_char","","If the value is a character, returns the associated…",0,[[],["option",4]]],[11,"is_nil","","Returns true if the value is `Nil`. Returns false otherwise.",0,[[]]],[11,"as_nil","","If the value is `Nil`, returns `()`. Returns `None`…",0,[[],["option",4]]],[11,"is_null","","Returns true if the value is `Null`. Returns false…",0,[[]]],[11,"as_null","","If the value is `Null`, returns `()`. Returns `None`…",0,[[],["option",4]]],[11,"is_cons","","Returns true if the value is a cons cell. Returns `False`…",0,[[]]],[11,"as_cons","","If the value is a cons cell, returns a reference to it.…",0,[[],[["cons",3],["option",4]]]],[11,"as_cons_mut","","If the value is a cons cell, returns a mutable reference…",0,[[],[["option",4],["cons",3]]]],[11,"as_pair","","If the value is a cons cell, return references to its…",0,[[],["option",4]]],[11,"is_vector","","Returns true if the value is a vector.",0,[[]]],[11,"as_slice","","If the value is a vector, return a reference to its…",0,[[],["option",4]]],[11,"as_slice_mut","","If the value is a vector, return a mutable reference to…",0,[[],["option",4]]],[11,"list_iter","","If the value is a list, return an iterator over the list…",0,[[],[["option",4],["listiter",3]]]],[11,"to_vec","","Attempts conversion to a vector, cloning the values.",0,[[],[["option",4],["vec",3]]]],[11,"to_ref_vec","","Attempts conversion to a vector, taking references to the…",0,[[],[["option",4],["vec",3]]]],[11,"get","","Index into a S-expression list. A string or `Value` value…",0,[[["index",8]],[["value",4],["option",4]]]],[8,"Index","lexpr","A type that can be used to index into a `lexpr::Value`.",null,null],[14,"sexp","","Construct a [`Value`] using syntax similar to regular…",null,null],[11,"from","lexpr::parse","",26,[[]]],[11,"into","","",26,[[]]],[11,"into_iter","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","lexpr::print","",35,[[]]],[11,"into","","",35,[[]]],[11,"borrow","","",35,[[]]],[11,"try_from","","",35,[[],["result",4]]],[11,"try_into","","",35,[[],["result",4]]],[11,"borrow_mut","","",35,[[]]],[11,"type_id","","",35,[[],["typeid",3]]],[11,"from","lexpr::datum","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","lexpr::cons","",1,[[]]],[11,"into","","",1,[[]]],[11,"into_iter","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","lexpr::number","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"to_string","","",10,[[],["string",3]]],[11,"borrow","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","lexpr::value","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","lexpr::parse","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"to_owned","","",13,[[]]],[11,"clone_into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","lexpr::cons","",2,[[]]],[11,"into","","",2,[[]]],[11,"into_iter","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"into_iter","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"into_iter","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","lexpr::datum","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",36,[[]]],[11,"into","","",36,[[]]],[11,"into_iter","","",36,[[]]],[11,"to_owned","","",36,[[]]],[11,"clone_into","","",36,[[]]],[11,"borrow","","",36,[[]]],[11,"try_from","","",36,[[],["result",4]]],[11,"try_into","","",36,[[],["result",4]]],[11,"borrow_mut","","",36,[[]]],[11,"type_id","","",36,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"into_iter","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"borrow","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","lexpr::parse","",21,[[]]],[11,"into","","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"borrow","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","","",22,[[]]],[11,"into","","",22,[[]]],[11,"borrow","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","","",23,[[]]],[11,"into","","",23,[[]]],[11,"borrow","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","lexpr::parse::error","",19,[[]]],[11,"into","","",19,[[]]],[11,"to_string","","",19,[[],["string",3]]],[11,"borrow","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","lexpr::parse","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_owned","","",25,[[]]],[11,"clone_into","","",25,[[]]],[11,"borrow","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","","",37,[[]]],[11,"into","","",37,[[]]],[11,"into_iter","","",37,[[]]],[11,"borrow","","",37,[[]]],[11,"try_from","","",37,[[],["result",4]]],[11,"try_into","","",37,[[],["result",4]]],[11,"borrow_mut","","",37,[[]]],[11,"type_id","","",37,[[],["typeid",3]]],[11,"from","","",38,[[]]],[11,"into","","",38,[[]]],[11,"into_iter","","",38,[[]]],[11,"borrow","","",38,[[]]],[11,"try_from","","",38,[[],["result",4]]],[11,"try_into","","",38,[[],["result",4]]],[11,"borrow_mut","","",38,[[]]],[11,"type_id","","",38,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"to_owned","","",14,[[]]],[11,"clone_into","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","","",15,[[]]],[11,"into","","",15,[[]]],[11,"to_owned","","",15,[[]]],[11,"clone_into","","",15,[[]]],[11,"borrow","","",15,[[]]],[11,"try_from","","",15,[[],["result",4]]],[11,"try_into","","",15,[[],["result",4]]],[11,"borrow_mut","","",15,[[]]],[11,"type_id","","",15,[[],["typeid",3]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_owned","","",16,[[]]],[11,"clone_into","","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"from","lexpr::parse::error","",18,[[]]],[11,"into","","",18,[[]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_owned","","",17,[[]]],[11,"clone_into","","",17,[[]]],[11,"borrow","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","lexpr::print","",34,[[]]],[11,"into","","",34,[[]]],[11,"to_owned","","",34,[[]]],[11,"clone_into","","",34,[[]]],[11,"borrow","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"try_into","","",34,[[],["result",4]]],[11,"borrow_mut","","",34,[[]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"from","","",39,[[]]],[11,"into","","",39,[[]]],[11,"to_owned","","",39,[[]]],[11,"clone_into","","",39,[[]]],[11,"borrow","","",39,[[]]],[11,"try_from","","",39,[[],["result",4]]],[11,"try_into","","",39,[[],["result",4]]],[11,"borrow_mut","","",39,[[]]],[11,"type_id","","",39,[[],["typeid",3]]],[11,"from","","",40,[[]]],[11,"into","","",40,[[]]],[11,"to_owned","","",40,[[]]],[11,"clone_into","","",40,[[]]],[11,"borrow","","",40,[[]]],[11,"try_from","","",40,[[],["result",4]]],[11,"try_into","","",40,[[],["result",4]]],[11,"borrow_mut","","",40,[[]]],[11,"type_id","","",40,[[],["typeid",3]]],[11,"from","","",27,[[]]],[11,"into","","",27,[[]]],[11,"to_owned","","",27,[[]]],[11,"clone_into","","",27,[[]]],[11,"borrow","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","","",28,[[]]],[11,"into","","",28,[[]]],[11,"to_owned","","",28,[[]]],[11,"clone_into","","",28,[[]]],[11,"borrow","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from","","",29,[[]]],[11,"into","","",29,[[]]],[11,"to_owned","","",29,[[]]],[11,"clone_into","","",29,[[]]],[11,"borrow","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"from","","",30,[[]]],[11,"into","","",30,[[]]],[11,"to_owned","","",30,[[]]],[11,"clone_into","","",30,[[]]],[11,"borrow","","",30,[[]]],[11,"try_from","","",30,[[],["result",4]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"from","","",31,[[]]],[11,"into","","",31,[[]]],[11,"borrow","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"from","","",32,[[]]],[11,"into","","",32,[[]]],[11,"borrow","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"next","lexpr::parse","",21,[[],[["result",6],["option",4]]]],[11,"peek","","",21,[[],[["result",6],["option",4]]]],[11,"discard","","",21,[[]]],[11,"position","","",21,[[],["position",3]]],[11,"peek_position","","",21,[[],["position",3]]],[11,"byte_offset","","",21,[[]]],[11,"parse_r6rs_str","","",21,[[["vec",3]],[["result",6],["reference",4]]]],[11,"parse_elisp_str","","",21,[[["vec",3]],[["elispstr",4],["result",6]]]],[11,"parse_symbol","","",21,[[["vec",3]],[["result",6],["reference",4]]]],[11,"next","","",22,[[],[["result",6],["option",4]]]],[11,"peek","","",22,[[],[["result",6],["option",4]]]],[11,"discard","","",22,[[]]],[11,"position","","",22,[[],["position",3]]],[11,"peek_position","","",22,[[],["position",3]]],[11,"byte_offset","","",22,[[]]],[11,"parse_r6rs_str","","",22,[[["vec",3]],[["result",6],["reference",4]]]],[11,"parse_elisp_str","","",22,[[["vec",3]],[["result",6],["elispstr",4]]]],[11,"parse_symbol","","",22,[[["vec",3]],[["result",6],["reference",4]]]],[11,"next","","",23,[[],[["result",6],["option",4]]]],[11,"peek","","",23,[[],[["result",6],["option",4]]]],[11,"discard","","",23,[[]]],[11,"position","","",23,[[],["position",3]]],[11,"peek_position","","",23,[[],["position",3]]],[11,"byte_offset","","",23,[[]]],[11,"parse_r6rs_str","","",23,[[["vec",3]],[["result",6],["reference",4]]]],[11,"parse_elisp_str","","",23,[[["vec",3]],[["result",6],["elispstr",4]]]],[11,"parse_symbol","","",23,[[["vec",3]],[["result",6],["reference",4]]]],[11,"write_nil","lexpr::print","",40,[[],["result",6]]],[11,"write_bool","","",40,[[],["result",6]]],[11,"write_keyword","","",40,[[],["result",6]]],[11,"begin_vector","","",40,[[["vectortype",4]],["result",6]]],[11,"end_vector","","",40,[[],["result",6]]],[11,"write_char","","",40,[[],["result",6]]],[11,"write_char_escape","","Writes a character escape code to the specified writer.",40,[[["charescape",4]],["result",6]]],[11,"write_bytes","","",40,[[],["result",6]]],[11,"index_into","lexpr::value","",0,[[["value",4]],[["value",4],["option",4]]]],[11,"as_ref","lexpr::datum","",6,[[],["value",4]]],[11,"from","lexpr::value","",0,[[["datum",3]]]],[11,"from","lexpr::datum","Turns a reference into an owned `Datum`, by cloning the…",5,[[["ref",3]]]],[11,"from","lexpr::number","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","","",10,[[]]],[11,"from","lexpr::value","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[["cow",4]]]],[11,"from","","",0,[[["box",3]]]],[11,"from","","",0,[[["string",3]]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[["box",3]]]],[11,"from","","",0,[[["vec",3]]]],[11,"from","","",0,[[["number",3]]]],[11,"from","","",0,[[]]],[11,"from","","",0,[[["cons",3]]]],[11,"from","","",0,[[["vec",3],["value",4]]]],[11,"from","","",0,[[["box",3]]]],[11,"into_iter","lexpr::cons","Obtains an iterator yielding the contents of the elements…",1,[[],["intoiter",3]]],[11,"next","","",2,[[],["option",4]]],[11,"next","","",3,[[],["option",4]]],[11,"next","","",4,[[],["option",4]]],[11,"next","lexpr::datum","",36,[[],["option",4]]],[11,"next","","",8,[[],["option",4]]],[11,"next","lexpr::parse","",26,[[],["option",4]]],[11,"next","","",37,[[],["option",4]]],[11,"next","","",38,[[],["option",4]]],[11,"clone","","",12,[[],["keywordsyntax",4]]],[11,"clone","","",13,[[],["stringsyntax",4]]],[11,"clone","","",11,[[],["charsyntax",4]]],[11,"clone","lexpr::cons","",1,[[],["cons",3]]],[11,"clone","","",4,[[],["listiter",3]]],[11,"clone","lexpr::datum","",5,[[],["datum",3]]],[11,"clone","","",6,[[],["ref",3]]],[11,"clone","","",7,[[],["span",3]]],[11,"clone","","",36,[[],["vectoriter",3]]],[11,"clone","","",8,[[],["listiter",3]]],[11,"clone","lexpr::number","",10,[[],["number",3]]],[11,"clone","lexpr::parse","",25,[[],["options",3]]],[11,"clone","","",14,[[],["nilsymbol",4]]],[11,"clone","","",15,[[],["tsymbol",4]]],[11,"clone","","",16,[[],["brackets",4]]],[11,"clone","lexpr::parse::error","",18,[[],["location",3]]],[11,"clone","","",17,[[],["category",4]]],[11,"clone","lexpr::parse","",20,[[],["position",3]]],[11,"clone","lexpr::print","",34,[[],["options",3]]],[11,"clone","","",27,[[],["nilsyntax",4]]],[11,"clone","","",28,[[],["boolsyntax",4]]],[11,"clone","","",29,[[],["vectorsyntax",4]]],[11,"clone","","",30,[[],["bytessyntax",4]]],[11,"clone","","",39,[[],["defaultformatter",3]]],[11,"clone","","",40,[[],["customizedformatter",3]]],[11,"clone","lexpr::value","",0,[[],["value",4]]],[11,"default","lexpr::parse","Construct a default set of options. This corresponds most…",25,[[]]],[11,"default","lexpr::print","",34,[[]]],[11,"cmp","lexpr::parse","",20,[[["position",3]],["ordering",4]]],[11,"eq","","",12,[[["keywordsyntax",4]]]],[11,"eq","","",13,[[["stringsyntax",4]]]],[11,"eq","","",11,[[["charsyntax",4]]]],[11,"eq","lexpr::cons","",1,[[["cons",3]]]],[11,"ne","","",1,[[["cons",3]]]],[11,"eq","lexpr::datum","",5,[[["datum",3]]]],[11,"ne","","",5,[[["datum",3]]]],[11,"eq","","",6,[[["ref",3]]]],[11,"ne","","",6,[[["ref",3]]]],[11,"eq","","",7,[[["span",3]]]],[11,"ne","","",7,[[["span",3]]]],[11,"eq","lexpr::number","",10,[[["number",3]]]],[11,"ne","","",10,[[["number",3]]]],[11,"eq","lexpr::parse","",14,[[["nilsymbol",4]]]],[11,"eq","","",15,[[["tsymbol",4]]]],[11,"eq","","",16,[[["brackets",4]]]],[11,"eq","lexpr::parse::error","",18,[[["location",3]]]],[11,"ne","","",18,[[["location",3]]]],[11,"eq","","",17,[[["category",4]]]],[11,"eq","lexpr::parse","",20,[[["position",3]]]],[11,"ne","","",20,[[["position",3]]]],[11,"eq","lexpr::value","",0,[[["value",4]]]],[11,"ne","","",0,[[["value",4]]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[["string",3]]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"partial_cmp","lexpr::parse","",20,[[["position",3]],[["option",4],["ordering",4]]]],[11,"lt","","",20,[[["position",3]]]],[11,"le","","",20,[[["position",3]]]],[11,"gt","","",20,[[["position",3]]]],[11,"ge","","",20,[[["position",3]]]],[11,"deref","lexpr::datum","",6,[[]]],[11,"fmt","lexpr::parse","",12,[[["formatter",3]],["result",6]]],[11,"fmt","","",13,[[["formatter",3]],["result",6]]],[11,"fmt","","",11,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::cons","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::datum","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",36,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::number","",10,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::parse","",25,[[["formatter",3]],["result",6]]],[11,"fmt","","",14,[[["formatter",3]],["result",6]]],[11,"fmt","","",15,[[["formatter",3]],["result",6]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::parse::error","",18,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",19,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::parse","",20,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::print","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",27,[[["formatter",3]],["result",6]]],[11,"fmt","","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",29,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",39,[[["formatter",3]],["result",6]]],[11,"fmt","","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::value","",0,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::number","",10,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::parse::error","",19,[[["formatter",3]],["result",6]]],[11,"fmt","lexpr::value","Display an S-expression value as a string.",0,[[["formatter",3]],["result",6]]],[11,"index","","Index into a `lexpr::Value` using the syntax `value[0]` or…",0,[[],["value",4]]],[11,"hash","lexpr::datum","",7,[[]]],[11,"hash","lexpr::parse","",20,[[]]],[11,"from_str","lexpr::value","",0,[[],["result",4]]],[11,"source","lexpr::parse::error","",19,[[],[["option",4],["error",8]]]],[11,"write","lexpr::print","",35,[[],["result",6]]],[11,"flush","","",35,[[],["result",6]]],[11,"parse_elisp_char","lexpr::parse","Parses an Emacs Lisp character constant.",24,[[["vec",3]],["result",6]]]],"p":[[4,"Value"],[3,"Cons"],[3,"Iter"],[3,"IntoIter"],[3,"ListIter"],[3,"Datum"],[3,"Ref"],[3,"Span"],[3,"ListIter"],[8,"Visitor"],[3,"Number"],[4,"CharSyntax"],[4,"KeywordSyntax"],[4,"StringSyntax"],[4,"NilSymbol"],[4,"TSymbol"],[4,"Brackets"],[4,"Category"],[3,"Location"],[3,"Error"],[3,"Position"],[3,"IoRead"],[3,"SliceRead"],[3,"StrRead"],[8,"Read"],[3,"Options"],[3,"Parser"],[4,"NilSyntax"],[4,"BoolSyntax"],[4,"VectorSyntax"],[4,"BytesSyntax"],[4,"CharEscape"],[4,"VectorType"],[8,"Formatter"],[3,"Options"],[3,"Printer"],[3,"VectorIter"],[3,"ValueIter"],[3,"DatumIter"],[3,"DefaultFormatter"],[3,"CustomizedFormatter"]]},\
"lexpr_macros":{"doc":"Internal crate implementing macros exposed by the `lexpr`…","i":[[24,"proc_macro_hack_sexp","lexpr_macros","",null,null]],"p":[]},\
"proc_macro2":{"doc":"A wrapper around the procedural macro API of the…","i":[[3,"TokenStream","proc_macro2","An abstract stream of tokens, or more concretely a…",null,null],[3,"LexError","","Error returned from `TokenStream::from_str`.",null,null],[3,"Span","","A region of source code, along with macro expansion…",null,null],[3,"Group","","A delimited token stream.",null,null],[3,"Punct","","An `Punct` is an single punctuation character like `+`,…",null,null],[3,"Ident","","A word of Rust code, which may be a keyword or legal…",null,null],[3,"Literal","","A literal string (`\\\"hello\\\"`), byte string (`b\\\"hello\\\"`),…",null,null],[4,"TokenTree","","A single token or a delimited sequence of token trees…",null,null],[13,"Group","","A token stream surrounded by bracket delimiters.",0,null],[13,"Ident","","An identifier.",0,null],[13,"Punct","","A single punctuation character (`+`, `,`, `$`, etc.).",0,null],[13,"Literal","","A literal character (`\'a\'`), string (`\\\"hello\\\"`), number…",0,null],[4,"Delimiter","","Describes how a sequence of token trees is delimited.",null,null],[13,"Parenthesis","","`( ... )`",1,null],[13,"Brace","","`{ ... }`",1,null],[13,"Bracket","","`[ ... ]`",1,null],[13,"None","","`Ø ... Ø`",1,null],[4,"Spacing","","Whether an `Punct` is followed immediately by another…",null,null],[13,"Alone","","E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.",2,null],[13,"Joint","","E.g. `+` is `Joint` in `+=` or `\'` is `Joint` in `\'#`.",2,null],[0,"token_stream","","Public implementation details for the `TokenStream` type,…",null,null],[3,"IntoIter","proc_macro2::token_stream","An iterator over `TokenStream`\'s `TokenTree`s.",null,null],[11,"new","proc_macro2","Returns an empty `TokenStream` containing no token trees.",3,[[],["tokenstream",3]]],[11,"is_empty","","Checks if this `TokenStream` is empty.",3,[[]]],[11,"call_site","","The span of the invocation of the current procedural macro.",4,[[],["span",3]]],[11,"unwrap","","Convert `proc_macro2::Span` to `proc_macro::Span`.",4,[[],["span",3]]],[11,"join","","Create a new span encompassing `self` and `other`.",4,[[["span",3]],[["span",3],["option",4]]]],[11,"span","","Returns the span of this tree, delegating to the `span`…",0,[[],["span",3]]],[11,"set_span","","Configures the span for only this token.",0,[[["span",3]]]],[11,"new","","Creates a new `Group` with the given delimiter and token…",5,[[["delimiter",4],["tokenstream",3]],["group",3]]],[11,"delimiter","","Returns the delimiter of this `Group`",5,[[],["delimiter",4]]],[11,"stream","","Returns the `TokenStream` of tokens that are delimited in…",5,[[],["tokenstream",3]]],[11,"span","","Returns the span for the delimiters of this token stream,…",5,[[],["span",3]]],[11,"span_open","","Returns the span pointing to the opening delimiter of this…",5,[[],["span",3]]],[11,"span_close","","Returns the span pointing to the closing delimiter of this…",5,[[],["span",3]]],[11,"set_span","","Configures the span for this `Group`\'s delimiters, but not…",5,[[["span",3]]]],[11,"new","","Creates a new `Punct` from the given character and spacing.",6,[[["spacing",4]],["punct",3]]],[11,"as_char","","Returns the value of this punctuation character as `char`.",6,[[]]],[11,"spacing","","Returns the spacing of this punctuation character,…",6,[[],["spacing",4]]],[11,"span","","Returns the span for this punctuation character.",6,[[],["span",3]]],[11,"set_span","","Configure the span for this punctuation character.",6,[[["span",3]]]],[11,"new","","Creates a new `Ident` with the given `string` as well as…",7,[[["span",3]],["ident",3]]],[11,"span","","Returns the span of this `Ident`.",7,[[],["span",3]]],[11,"set_span","","Configures the span of this `Ident`, possibly changing its…",7,[[["span",3]]]],[11,"u8_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"u16_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"u32_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"u64_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"u128_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"usize_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"i8_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"i16_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"i32_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"i64_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"i128_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"isize_suffixed","","Creates a new suffixed integer literal with the specified…",8,[[],["literal",3]]],[11,"u8_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"u16_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"u32_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"u64_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"u128_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"usize_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"i8_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"i16_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"i32_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"i64_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"i128_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"isize_unsuffixed","","Creates a new unsuffixed integer literal with the…",8,[[],["literal",3]]],[11,"f64_unsuffixed","","Creates a new unsuffixed floating-point literal.",8,[[],["literal",3]]],[11,"f64_suffixed","","Creates a new suffixed floating-point literal.",8,[[],["literal",3]]],[11,"f32_unsuffixed","","Creates a new unsuffixed floating-point literal.",8,[[],["literal",3]]],[11,"f32_suffixed","","Creates a new suffixed floating-point literal.",8,[[],["literal",3]]],[11,"string","","String literal.",8,[[],["literal",3]]],[11,"character","","Character literal.",8,[[],["literal",3]]],[11,"byte_string","","Byte string literal.",8,[[],["literal",3]]],[11,"span","","Returns the span encompassing this literal.",8,[[],["span",3]]],[11,"set_span","","Configures the span associated for this literal.",8,[[["span",3]]]],[11,"subspan","","Returns a `Span` that is a subset of `self.span()`…",8,[[["rangebounds",8]],[["span",3],["option",4]]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"into_iter","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"to_string","","",3,[[],["string",3]]],[11,"borrow","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"to_string","","",5,[[],["string",3]]],[11,"borrow","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"to_string","","",6,[[],["string",3]]],[11,"borrow","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"to_string","","",7,[[],["string",3]]],[11,"borrow","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","","",8,[[]]],[11,"into","","",8,[[]]],[11,"to_owned","","",8,[[]]],[11,"clone_into","","",8,[[]]],[11,"to_string","","",8,[[],["string",3]]],[11,"borrow","","",8,[[]]],[11,"try_from","","",8,[[],["result",4]]],[11,"try_into","","",8,[[],["result",4]]],[11,"borrow_mut","","",8,[[]]],[11,"type_id","","",8,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","proc_macro2::token_stream","",10,[[]]],[11,"into","","",10,[[]]],[11,"into_iter","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","proc_macro2","",4,[[["span",3]],["span",3]]],[11,"from","","",3,[[["tokenstream",3]],["tokenstream",3]]],[11,"from","","",3,[[["tokentree",4]]]],[11,"from","","",0,[[["group",3]],["tokentree",4]]],[11,"from","","",0,[[["ident",3]],["tokentree",4]]],[11,"from","","",0,[[["punct",3]],["tokentree",4]]],[11,"from","","",0,[[["literal",3]],["tokentree",4]]],[11,"extend","","",3,[[["intoiterator",8]]]],[11,"extend","","",3,[[["intoiterator",8]]]],[11,"into_iter","","",3,[[],["intoiter",3]]],[11,"next","proc_macro2::token_stream","",10,[[],[["option",4],["tokentree",4]]]],[11,"clone","proc_macro2","",3,[[],["tokenstream",3]]],[11,"clone","","",4,[[],["span",3]]],[11,"clone","","",0,[[],["tokentree",4]]],[11,"clone","","",5,[[],["group",3]]],[11,"clone","","",1,[[],["delimiter",4]]],[11,"clone","","",6,[[],["punct",3]]],[11,"clone","","",2,[[],["spacing",4]]],[11,"clone","","",7,[[],["ident",3]]],[11,"clone","","",8,[[],["literal",3]]],[11,"clone","proc_macro2::token_stream","",10,[[],["intoiter",3]]],[11,"default","proc_macro2","",3,[[]]],[11,"cmp","","",7,[[["ident",3]],["ordering",4]]],[11,"eq","","",1,[[["delimiter",4]]]],[11,"eq","","",2,[[["spacing",4]]]],[11,"eq","","",7,[[["ident",3]]]],[11,"eq","","",7,[[]]],[11,"partial_cmp","","",7,[[["ident",3]],[["option",4],["ordering",4]]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",9,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"fmt","proc_macro2::token_stream","",10,[[["formatter",3]],["result",6]]],[11,"fmt","proc_macro2","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","","",7,[[["formatter",3]],["result",6]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"hash","","",7,[[]]],[11,"from_iter","","",3,[[["intoiterator",8]]]],[11,"from_iter","","",3,[[["intoiterator",8]]]],[11,"from_str","","",3,[[],[["result",4],["lexerror",3],["tokenstream",3]]]]],"p":[[4,"TokenTree"],[4,"Delimiter"],[4,"Spacing"],[3,"TokenStream"],[3,"Span"],[3,"Group"],[3,"Punct"],[3,"Ident"],[3,"Literal"],[3,"LexError"],[3,"IntoIter"]]},\
"proc_macro_hack":{"doc":"As of Rust 1.30, the language supports user-defined…","i":[[23,"proc_macro_hack","proc_macro_hack","",null,null]],"p":[]},\
"quote":{"doc":"This crate provides the [`quote!`] macro for turning Rust…","i":[[8,"TokenStreamExt","quote","TokenStream extension trait with methods for appending…",null,null],[10,"append","","For use by `ToTokens` implementations.",0,[[]]],[10,"append_all","","For use by `ToTokens` implementations.",0,[[]]],[10,"append_separated","","For use by `ToTokens` implementations.",0,[[]]],[10,"append_terminated","","For use by `ToTokens` implementations.",0,[[]]],[8,"IdentFragment","","Specialized formatting trait used by `format_ident!`.",null,null],[10,"fmt","","Format this value as an identifier fragment.",1,[[["formatter",3]],["result",6]]],[11,"span","","Span associated with this `IdentFragment`.",1,[[],[["span",3],["option",4]]]],[8,"ToTokens","","Types that can be interpolated inside a `quote!` invocation.",null,null],[10,"to_tokens","","Write `self` to the given `TokenStream`.",2,[[["tokenstream",3]]]],[11,"to_token_stream","","Convert `self` directly into a `TokenStream` object.",2,[[],["tokenstream",3]]],[11,"into_token_stream","","Convert `self` directly into a `TokenStream` object.",2,[[],["tokenstream",3]]],[14,"format_ident","","Formatting macro for constructing `Ident`s.",null,null],[14,"quote","","The whole point.",null,null],[14,"quote_spanned","","Same as `quote!`, but applies a given span to all tokens…",null,null],[11,"span","","Span associated with this `IdentFragment`.",1,[[],[["span",3],["option",4]]]],[11,"to_token_stream","","Convert `self` directly into a `TokenStream` object.",2,[[],["tokenstream",3]]],[11,"into_token_stream","","Convert `self` directly into a `TokenStream` object.",2,[[],["tokenstream",3]]]],"p":[[8,"TokenStreamExt"],[8,"IdentFragment"],[8,"ToTokens"]]},\
"ryu":{"doc":"Pure Rust implementation of Ryū, an algorithm to quickly…","i":[[3,"Buffer","ryu","Safe API for formatting floating point numbers to text.",null,null],[11,"new","","This is a cheap operation; you don\'t need to worry about…",0,[[]]],[11,"format","","Print a floating point number into this buffer and return…",0,[[["float",8]]]],[11,"format_finite","","Print a floating point number into this buffer and return…",0,[[["float",8]]]],[0,"raw","","Unsafe functions that mirror the API of the C…",null,null],[5,"format32","ryu::raw","Print f32 to the given buffer and return number of bytes…",null,[[]]],[5,"format64","","Print f64 to the given buffer and return number of bytes…",null,[[]]],[8,"Float","ryu","A floating point number, f32 or f64, that can be written…",null,null],[11,"from","","",0,[[]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"into","","",0,[[]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"clone","","",0,[[],["buffer",3]]],[11,"default","","",0,[[]]]],"p":[[3,"Buffer"]]},\
"serde":{"doc":"Serde","i":[[0,"de","serde","Generic data structure deserialization framework.",null,null],[3,"IgnoredAny","serde::de","An efficient way of discarding data from a deserializer.",null,null],[4,"Unexpected","","`Unexpected` represents an unexpected invocation of any…",null,null],[13,"Bool","","The input contained a boolean value that was not expected.",0,null],[13,"Unsigned","","The input contained an unsigned integer `u8`, `u16`, `u32`…",0,null],[13,"Signed","","The input contained a signed integer `i8`, `i16`, `i32` or…",0,null],[13,"Float","","The input contained a floating point `f32` or `f64` that…",0,null],[13,"Char","","The input contained a `char` that was not expected.",0,null],[13,"Str","","The input contained a `&str` or `String` that was not…",0,null],[13,"Bytes","","The input contained a `&[u8]` or `Vec<u8>` that was not…",0,null],[13,"Unit","","The input contained a unit `()` that was not expected.",0,null],[13,"Option","","The input contained an `Option<T>` that was not expected.",0,null],[13,"NewtypeStruct","","The input contained a newtype struct that was not expected.",0,null],[13,"Seq","","The input contained a sequence that was not expected.",0,null],[13,"Map","","The input contained a map that was not expected.",0,null],[13,"Enum","","The input contained an enum that was not expected.",0,null],[13,"UnitVariant","","The input contained a unit variant that was not expected.",0,null],[13,"NewtypeVariant","","The input contained a newtype variant that was not expected.",0,null],[13,"TupleVariant","","The input contained a tuple variant that was not expected.",0,null],[13,"StructVariant","","The input contained a struct variant that was not expected.",0,null],[13,"Other","","A message stating what uncategorized thing the input…",0,null],[0,"value","","Building blocks for deserializing basic values using the…",null,null],[3,"Error","serde::de::value","A minimal representation of all possible errors that can…",null,null],[3,"UnitDeserializer","","A deserializer holding a `()`.",null,null],[3,"BoolDeserializer","","A deserializer holding a `bool`.",null,null],[3,"I8Deserializer","","A deserializer holding an `i8`.",null,null],[3,"I16Deserializer","","A deserializer holding an `i16`.",null,null],[3,"I32Deserializer","","A deserializer holding an `i32`.",null,null],[3,"I64Deserializer","","A deserializer holding an `i64`.",null,null],[3,"IsizeDeserializer","","A deserializer holding an `isize`.",null,null],[3,"U8Deserializer","","A deserializer holding a `u8`.",null,null],[3,"U16Deserializer","","A deserializer holding a `u16`.",null,null],[3,"U64Deserializer","","A deserializer holding a `u64`.",null,null],[3,"UsizeDeserializer","","A deserializer holding a `usize`.",null,null],[3,"F32Deserializer","","A deserializer holding an `f32`.",null,null],[3,"F64Deserializer","","A deserializer holding an `f64`.",null,null],[3,"CharDeserializer","","A deserializer holding a `char`.",null,null],[3,"I128Deserializer","","A deserializer holding an `i128`.",null,null],[3,"U128Deserializer","","A deserializer holding a `u128`.",null,null],[3,"U32Deserializer","","A deserializer holding a `u32`.",null,null],[3,"StrDeserializer","","A deserializer holding a `&str`.",null,null],[3,"BorrowedStrDeserializer","","A deserializer holding a `&str` with a lifetime tied to…",null,null],[3,"StringDeserializer","","A deserializer holding a `String`.",null,null],[3,"CowStrDeserializer","","A deserializer holding a `Cow<str>`.",null,null],[3,"BorrowedBytesDeserializer","","A deserializer holding a `&[u8]` with a lifetime tied to…",null,null],[3,"SeqDeserializer","","A deserializer that iterates over a sequence.",null,null],[3,"SeqAccessDeserializer","","A deserializer holding a `SeqAccess`.",null,null],[3,"MapDeserializer","","A deserializer that iterates over a map.",null,null],[3,"MapAccessDeserializer","","A deserializer holding a `MapAccess`.",null,null],[11,"new","","Create a new borrowed deserializer from the given string.",1,[[],["borrowedstrdeserializer",3]]],[11,"new","","Create a new borrowed deserializer from the given byte…",2,[[],["borrowedbytesdeserializer",3]]],[11,"new","","Construct a new `SeqDeserializer<I, E>`.",3,[[]]],[11,"end","","Check for remaining elements after passing a…",3,[[],["result",4]]],[11,"new","","Construct a new `SeqAccessDeserializer<A>`.",4,[[]]],[11,"new","","Construct a new `MapDeserializer<I, E>`.",5,[[]]],[11,"end","","Check for remaining elements after passing a…",5,[[],["result",4]]],[11,"new","","Construct a new `MapAccessDeserializer<A>`.",6,[[]]],[8,"Error","serde::de","The `Error` trait allows `Deserialize` implementations to…",null,null],[10,"custom","","Raised when there is general error when deserializing a…",7,[[]]],[11,"invalid_type","","Raised when a `Deserialize` receives a type different from…",7,[[["expected",8],["unexpected",4]]]],[11,"invalid_value","","Raised when a `Deserialize` receives a value of the right…",7,[[["expected",8],["unexpected",4]]]],[11,"invalid_length","","Raised when deserializing a sequence or map and the input…",7,[[["expected",8]]]],[11,"unknown_variant","","Raised when a `Deserialize` enum type received a variant…",7,[[]]],[11,"unknown_field","","Raised when a `Deserialize` struct type received a field…",7,[[]]],[11,"missing_field","","Raised when a `Deserialize` struct type expected to…",7,[[]]],[11,"duplicate_field","","Raised when a `Deserialize` struct type received more than…",7,[[]]],[8,"Expected","","`Expected` represents an explanation of what data a…",null,null],[10,"fmt","","Format an explanation of what data was being expected.…",8,[[["formatter",3]],["result",6]]],[8,"Deserialize","","A data structure that can be deserialized from any data…",null,null],[10,"deserialize","","Deserialize this value from the given Serde deserializer.",9,[[],["result",4]]],[8,"DeserializeOwned","","A data structure that can be deserialized without…",null,null],[8,"DeserializeSeed","","`DeserializeSeed` is the stateful form of the…",null,null],[16,"Value","","The type produced by using this seed.",10,null],[10,"deserialize","","Equivalent to the more common `Deserialize::deserialize`…",10,[[],["result",4]]],[8,"Deserializer","","A data format that can deserialize any data structure…",null,null],[16,"Error","","The error type that can be returned if some error occurs…",11,null],[10,"deserialize_any","","Require the `Deserializer` to figure out how to drive the…",11,[[],["result",4]]],[10,"deserialize_bool","","Hint that the `Deserialize` type is expecting a `bool`…",11,[[],["result",4]]],[10,"deserialize_i8","","Hint that the `Deserialize` type is expecting an `i8` value.",11,[[],["result",4]]],[10,"deserialize_i16","","Hint that the `Deserialize` type is expecting an `i16`…",11,[[],["result",4]]],[10,"deserialize_i32","","Hint that the `Deserialize` type is expecting an `i32`…",11,[[],["result",4]]],[10,"deserialize_i64","","Hint that the `Deserialize` type is expecting an `i64`…",11,[[],["result",4]]],[11,"deserialize_i128","","Hint that the `Deserialize` type is expecting an `i128`…",11,[[],["result",4]]],[10,"deserialize_u8","","Hint that the `Deserialize` type is expecting a `u8` value.",11,[[],["result",4]]],[10,"deserialize_u16","","Hint that the `Deserialize` type is expecting a `u16` value.",11,[[],["result",4]]],[10,"deserialize_u32","","Hint that the `Deserialize` type is expecting a `u32` value.",11,[[],["result",4]]],[10,"deserialize_u64","","Hint that the `Deserialize` type is expecting a `u64` value.",11,[[],["result",4]]],[11,"deserialize_u128","","Hint that the `Deserialize` type is expecting an `u128`…",11,[[],["result",4]]],[10,"deserialize_f32","","Hint that the `Deserialize` type is expecting a `f32` value.",11,[[],["result",4]]],[10,"deserialize_f64","","Hint that the `Deserialize` type is expecting a `f64` value.",11,[[],["result",4]]],[10,"deserialize_char","","Hint that the `Deserialize` type is expecting a `char`…",11,[[],["result",4]]],[10,"deserialize_str","","Hint that the `Deserialize` type is expecting a string…",11,[[],["result",4]]],[10,"deserialize_string","","Hint that the `Deserialize` type is expecting a string…",11,[[],["result",4]]],[10,"deserialize_bytes","","Hint that the `Deserialize` type is expecting a byte array…",11,[[],["result",4]]],[10,"deserialize_byte_buf","","Hint that the `Deserialize` type is expecting a byte array…",11,[[],["result",4]]],[10,"deserialize_option","","Hint that the `Deserialize` type is expecting an optional…",11,[[],["result",4]]],[10,"deserialize_unit","","Hint that the `Deserialize` type is expecting a unit value.",11,[[],["result",4]]],[10,"deserialize_unit_struct","","Hint that the `Deserialize` type is expecting a unit…",11,[[],["result",4]]],[10,"deserialize_newtype_struct","","Hint that the `Deserialize` type is expecting a newtype…",11,[[],["result",4]]],[10,"deserialize_seq","","Hint that the `Deserialize` type is expecting a sequence…",11,[[],["result",4]]],[10,"deserialize_tuple","","Hint that the `Deserialize` type is expecting a sequence…",11,[[],["result",4]]],[10,"deserialize_tuple_struct","","Hint that the `Deserialize` type is expecting a tuple…",11,[[],["result",4]]],[10,"deserialize_map","","Hint that the `Deserialize` type is expecting a map of…",11,[[],["result",4]]],[10,"deserialize_struct","","Hint that the `Deserialize` type is expecting a struct…",11,[[],["result",4]]],[10,"deserialize_enum","","Hint that the `Deserialize` type is expecting an enum…",11,[[],["result",4]]],[10,"deserialize_identifier","","Hint that the `Deserialize` type is expecting the name of…",11,[[],["result",4]]],[10,"deserialize_ignored_any","","Hint that the `Deserialize` type needs to deserialize a…",11,[[],["result",4]]],[11,"is_human_readable","","Determine whether `Deserialize` implementations should…",11,[[]]],[8,"Visitor","","This trait represents a visitor that walks through a…",null,null],[16,"Value","","The value produced by this visitor.",12,null],[10,"expecting","","Format a message stating what data this Visitor expects to…",12,[[["formatter",3]],["result",6]]],[11,"visit_bool","","The input contains a boolean.",12,[[],["result",4]]],[11,"visit_i8","","The input contains an `i8`.",12,[[],["result",4]]],[11,"visit_i16","","The input contains an `i16`.",12,[[],["result",4]]],[11,"visit_i32","","The input contains an `i32`.",12,[[],["result",4]]],[11,"visit_i64","","The input contains an `i64`.",12,[[],["result",4]]],[11,"visit_i128","","The input contains a `i128`.",12,[[],["result",4]]],[11,"visit_u8","","The input contains a `u8`.",12,[[],["result",4]]],[11,"visit_u16","","The input contains a `u16`.",12,[[],["result",4]]],[11,"visit_u32","","The input contains a `u32`.",12,[[],["result",4]]],[11,"visit_u64","","The input contains a `u64`.",12,[[],["result",4]]],[11,"visit_u128","","The input contains a `u128`.",12,[[],["result",4]]],[11,"visit_f32","","The input contains an `f32`.",12,[[],["result",4]]],[11,"visit_f64","","The input contains an `f64`.",12,[[],["result",4]]],[11,"visit_char","","The input contains a `char`.",12,[[],["result",4]]],[11,"visit_str","","The input contains a string. The lifetime of the string is…",12,[[],["result",4]]],[11,"visit_borrowed_str","","The input contains a string that lives at least as long as…",12,[[],["result",4]]],[11,"visit_string","","The input contains a string and ownership of the string is…",12,[[["string",3]],["result",4]]],[11,"visit_bytes","","The input contains a byte array. The lifetime of the byte…",12,[[],["result",4]]],[11,"visit_borrowed_bytes","","The input contains a byte array that lives at least as…",12,[[],["result",4]]],[11,"visit_byte_buf","","The input contains a byte array and ownership of the byte…",12,[[["vec",3]],["result",4]]],[11,"visit_none","","The input contains an optional that is absent.",12,[[],["result",4]]],[11,"visit_some","","The input contains an optional that is present.",12,[[],["result",4]]],[11,"visit_unit","","The input contains a unit `()`.",12,[[],["result",4]]],[11,"visit_newtype_struct","","The input contains a newtype struct.",12,[[],["result",4]]],[11,"visit_seq","","The input contains a sequence of elements.",12,[[],["result",4]]],[11,"visit_map","","The input contains a key-value map.",12,[[],["result",4]]],[11,"visit_enum","","The input contains an enum.",12,[[],["result",4]]],[8,"SeqAccess","","Provides a `Visitor` access to each element of a sequence…",null,null],[16,"Error","","The error type that can be returned if some error occurs…",13,null],[10,"next_element_seed","","This returns `Ok(Some(value))` for the next value in the…",13,[[],[["option",4],["result",4]]]],[11,"next_element","","This returns `Ok(Some(value))` for the next value in the…",13,[[],[["option",4],["result",4]]]],[11,"size_hint","","Returns the number of elements remaining in the sequence,…",13,[[],["option",4]]],[8,"MapAccess","","Provides a `Visitor` access to each entry of a map in the…",null,null],[16,"Error","","The error type that can be returned if some error occurs…",14,null],[10,"next_key_seed","","This returns `Ok(Some(key))` for the next key in the map,…",14,[[],[["result",4],["option",4]]]],[10,"next_value_seed","","This returns a `Ok(value)` for the next value in the map.",14,[[],["result",4]]],[11,"next_entry_seed","","This returns `Ok(Some((key, value)))` for the next…",14,[[],[["result",4],["option",4]]]],[11,"next_key","","This returns `Ok(Some(key))` for the next key in the map,…",14,[[],[["result",4],["option",4]]]],[11,"next_value","","This returns a `Ok(value)` for the next value in the map.",14,[[],["result",4]]],[11,"next_entry","","This returns `Ok(Some((key, value)))` for the next…",14,[[],[["option",4],["result",4]]]],[11,"size_hint","","Returns the number of entries remaining in the map, if…",14,[[],["option",4]]],[8,"EnumAccess","","Provides a `Visitor` access to the data of an enum in the…",null,null],[16,"Error","","The error type that can be returned if some error occurs…",15,null],[16,"Variant","","The `Visitor` that will be used to deserialize the content…",15,null],[10,"variant_seed","","`variant` is called to identify which variant to…",15,[[],["result",4]]],[11,"variant","","`variant` is called to identify which variant to…",15,[[],["result",4]]],[8,"VariantAccess","","`VariantAccess` is a visitor that is created by the…",null,null],[16,"Error","","The error type that can be returned if some error occurs…",16,null],[10,"unit_variant","","Called when deserializing a variant with no values.",16,[[],["result",4]]],[10,"newtype_variant_seed","","Called when deserializing a variant with a single value.",16,[[],["result",4]]],[11,"newtype_variant","","Called when deserializing a variant with a single value.",16,[[],["result",4]]],[10,"tuple_variant","","Called when deserializing a tuple-like variant.",16,[[],["result",4]]],[10,"struct_variant","","Called when deserializing a struct-like variant.",16,[[],["result",4]]],[8,"IntoDeserializer","","Converts an existing value into a `Deserializer` from…",null,null],[16,"Deserializer","","The type of the deserializer being converted into.",17,null],[10,"into_deserializer","","Convert this value into a deserializer.",17,[[]]],[0,"ser","serde","Generic data structure serialization framework.",null,null],[3,"Impossible","serde::ser","Helper type for implementing a `Serializer` that does not…",null,null],[8,"Error","","Trait used by `Serialize` implementations to generically…",null,null],[10,"custom","","Used when a [`Serialize`] implementation encounters any…",18,[[]]],[8,"Serialize","","A data structure that can be serialized into any data…",null,null],[10,"serialize","","Serialize this value into the given Serde serializer.",19,[[],["result",4]]],[8,"Serializer","","A data format that can serialize any data structure…",null,null],[16,"Ok","","The output type produced by this `Serializer` during…",20,null],[16,"Error","","The error type when some error occurs during serialization.",20,null],[16,"SerializeSeq","","Type returned from [`serialize_seq`] for serializing the…",20,null],[16,"SerializeTuple","","Type returned from [`serialize_tuple`] for serializing the…",20,null],[16,"SerializeTupleStruct","","Type returned from [`serialize_tuple_struct`] for…",20,null],[16,"SerializeTupleVariant","","Type returned from [`serialize_tuple_variant`] for…",20,null],[16,"SerializeMap","","Type returned from [`serialize_map`] for serializing the…",20,null],[16,"SerializeStruct","","Type returned from [`serialize_struct`] for serializing…",20,null],[16,"SerializeStructVariant","","Type returned from [`serialize_struct_variant`] for…",20,null],[10,"serialize_bool","","Serialize a `bool` value.",20,[[],["result",4]]],[10,"serialize_i8","","Serialize an `i8` value.",20,[[],["result",4]]],[10,"serialize_i16","","Serialize an `i16` value.",20,[[],["result",4]]],[10,"serialize_i32","","Serialize an `i32` value.",20,[[],["result",4]]],[10,"serialize_i64","","Serialize an `i64` value.",20,[[],["result",4]]],[11,"serialize_i128","","Serialize an `i128` value.",20,[[],["result",4]]],[10,"serialize_u8","","Serialize a `u8` value.",20,[[],["result",4]]],[10,"serialize_u16","","Serialize a `u16` value.",20,[[],["result",4]]],[10,"serialize_u32","","Serialize a `u32` value.",20,[[],["result",4]]],[10,"serialize_u64","","Serialize a `u64` value.",20,[[],["result",4]]],[11,"serialize_u128","","Serialize a `u128` value.",20,[[],["result",4]]],[10,"serialize_f32","","Serialize an `f32` value.",20,[[],["result",4]]],[10,"serialize_f64","","Serialize an `f64` value.",20,[[],["result",4]]],[10,"serialize_char","","Serialize a character.",20,[[],["result",4]]],[10,"serialize_str","","Serialize a `&str`.",20,[[],["result",4]]],[10,"serialize_bytes","","Serialize a chunk of raw byte data.",20,[[],["result",4]]],[10,"serialize_none","","Serialize a [`None`] value.",20,[[],["result",4]]],[10,"serialize_some","","Serialize a [`Some(T)`] value.",20,[[],["result",4]]],[10,"serialize_unit","","Serialize a `()` value.",20,[[],["result",4]]],[10,"serialize_unit_struct","","Serialize a unit struct like `struct Unit` or…",20,[[],["result",4]]],[10,"serialize_unit_variant","","Serialize a unit variant like `E::A` in `enum E { A, B }`.",20,[[],["result",4]]],[10,"serialize_newtype_struct","","Serialize a newtype struct like `struct Millimeters(u8)`.",20,[[],["result",4]]],[10,"serialize_newtype_variant","","Serialize a newtype variant like `E::N` in `enum E { N(u8)…",20,[[],["result",4]]],[10,"serialize_seq","","Begin to serialize a variably sized sequence. This call…",20,[[["option",4]],["result",4]]],[10,"serialize_tuple","","Begin to serialize a statically sized sequence whose…",20,[[],["result",4]]],[10,"serialize_tuple_struct","","Begin to serialize a tuple struct like `struct Rgb(u8, u8,…",20,[[],["result",4]]],[10,"serialize_tuple_variant","","Begin to serialize a tuple variant like `E::T` in `enum E…",20,[[],["result",4]]],[10,"serialize_map","","Begin to serialize a map. This call must be followed by…",20,[[["option",4]],["result",4]]],[10,"serialize_struct","","Begin to serialize a struct like `struct Rgb { r: u8, g:…",20,[[],["result",4]]],[10,"serialize_struct_variant","","Begin to serialize a struct variant like `E::S` in `enum E…",20,[[],["result",4]]],[11,"collect_seq","","Collect an iterator as a sequence.",20,[[],["result",4]]],[11,"collect_map","","Collect an iterator as a map.",20,[[],["result",4]]],[11,"collect_str","","Serialize a string produced by an implementation of…",20,[[],["result",4]]],[11,"is_human_readable","","Determine whether `Serialize` implementations should…",20,[[]]],[8,"SerializeSeq","","Returned from `Serializer::serialize_seq`.",null,null],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",21,null],[16,"Error","","Must match the `Error` type of our `Serializer`.",21,null],[10,"serialize_element","","Serialize a sequence element.",21,[[],["result",4]]],[10,"end","","Finish serializing a sequence.",21,[[],["result",4]]],[8,"SerializeTuple","","Returned from `Serializer::serialize_tuple`.",null,null],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",22,null],[16,"Error","","Must match the `Error` type of our `Serializer`.",22,null],[10,"serialize_element","","Serialize a tuple element.",22,[[],["result",4]]],[10,"end","","Finish serializing a tuple.",22,[[],["result",4]]],[8,"SerializeTupleStruct","","Returned from `Serializer::serialize_tuple_struct`.",null,null],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",23,null],[16,"Error","","Must match the `Error` type of our `Serializer`.",23,null],[10,"serialize_field","","Serialize a tuple struct field.",23,[[],["result",4]]],[10,"end","","Finish serializing a tuple struct.",23,[[],["result",4]]],[8,"SerializeTupleVariant","","Returned from `Serializer::serialize_tuple_variant`.",null,null],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",24,null],[16,"Error","","Must match the `Error` type of our `Serializer`.",24,null],[10,"serialize_field","","Serialize a tuple variant field.",24,[[],["result",4]]],[10,"end","","Finish serializing a tuple variant.",24,[[],["result",4]]],[8,"SerializeMap","","Returned from `Serializer::serialize_map`.",null,null],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",25,null],[16,"Error","","Must match the `Error` type of our `Serializer`.",25,null],[10,"serialize_key","","Serialize a map key.",25,[[],["result",4]]],[10,"serialize_value","","Serialize a map value.",25,[[],["result",4]]],[11,"serialize_entry","","Serialize a map entry consisting of a key and a value.",25,[[],["result",4]]],[10,"end","","Finish serializing a map.",25,[[],["result",4]]],[8,"SerializeStruct","","Returned from `Serializer::serialize_struct`.",null,null],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",26,null],[16,"Error","","Must match the `Error` type of our `Serializer`.",26,null],[10,"serialize_field","","Serialize a struct field.",26,[[],["result",4]]],[11,"skip_field","","Indicate that a struct field has been skipped.",26,[[],["result",4]]],[10,"end","","Finish serializing a struct.",26,[[],["result",4]]],[8,"SerializeStructVariant","","Returned from `Serializer::serialize_struct_variant`.",null,null],[16,"Ok","","Must match the `Ok` type of our `Serializer`.",27,null],[16,"Error","","Must match the `Error` type of our `Serializer`.",27,null],[10,"serialize_field","","Serialize a struct variant field.",27,[[],["result",4]]],[11,"skip_field","","Indicate that a struct variant field has been skipped.",27,[[],["result",4]]],[10,"end","","Finish serializing a struct variant.",27,[[],["result",4]]],[8,"Deserialize","serde","A data structure that can be deserialized from any data…",null,null],[10,"deserialize","","Deserialize this value from the given Serde deserializer.",9,[[],["result",4]]],[8,"Deserializer","","A data format that can deserialize any data structure…",null,null],[16,"Error","","The error type that can be returned if some error occurs…",11,null],[10,"deserialize_any","","Require the `Deserializer` to figure out how to drive the…",11,[[],["result",4]]],[10,"deserialize_bool","","Hint that the `Deserialize` type is expecting a `bool`…",11,[[],["result",4]]],[10,"deserialize_i8","","Hint that the `Deserialize` type is expecting an `i8` value.",11,[[],["result",4]]],[10,"deserialize_i16","","Hint that the `Deserialize` type is expecting an `i16`…",11,[[],["result",4]]],[10,"deserialize_i32","","Hint that the `Deserialize` type is expecting an `i32`…",11,[[],["result",4]]],[10,"deserialize_i64","","Hint that the `Deserialize` type is expecting an `i64`…",11,[[],["result",4]]],[11,"deserialize_i128","","Hint that the `Deserialize` type is expecting an `i128`…",11,[[],["result",4]]],[10,"deserialize_u8","","Hint that the `Deserialize` type is expecting a `u8` value.",11,[[],["result",4]]],[10,"deserialize_u16","","Hint that the `Deserialize` type is expecting a `u16` value.",11,[[],["result",4]]],[10,"deserialize_u32","","Hint that the `Deserialize` type is expecting a `u32` value.",11,[[],["result",4]]],[10,"deserialize_u64","","Hint that the `Deserialize` type is expecting a `u64` value.",11,[[],["result",4]]],[11,"deserialize_u128","","Hint that the `Deserialize` type is expecting an `u128`…",11,[[],["result",4]]],[10,"deserialize_f32","","Hint that the `Deserialize` type is expecting a `f32` value.",11,[[],["result",4]]],[10,"deserialize_f64","","Hint that the `Deserialize` type is expecting a `f64` value.",11,[[],["result",4]]],[10,"deserialize_char","","Hint that the `Deserialize` type is expecting a `char`…",11,[[],["result",4]]],[10,"deserialize_str","","Hint that the `Deserialize` type is expecting a string…",11,[[],["result",4]]],[10,"deserialize_string","","Hint that the `Deserialize` type is expecting a string…",11,[[],["result",4]]],[10,"deserialize_bytes","","Hint that the `Deserialize` type is expecting a byte array…",11,[[],["result",4]]],[10,"deserialize_byte_buf","","Hint that the `Deserialize` type is expecting a byte array…",11,[[],["result",4]]],[10,"deserialize_option","","Hint that the `Deserialize` type is expecting an optional…",11,[[],["result",4]]],[10,"deserialize_unit","","Hint that the `Deserialize` type is expecting a unit value.",11,[[],["result",4]]],[10,"deserialize_unit_struct","","Hint that the `Deserialize` type is expecting a unit…",11,[[],["result",4]]],[10,"deserialize_newtype_struct","","Hint that the `Deserialize` type is expecting a newtype…",11,[[],["result",4]]],[10,"deserialize_seq","","Hint that the `Deserialize` type is expecting a sequence…",11,[[],["result",4]]],[10,"deserialize_tuple","","Hint that the `Deserialize` type is expecting a sequence…",11,[[],["result",4]]],[10,"deserialize_tuple_struct","","Hint that the `Deserialize` type is expecting a tuple…",11,[[],["result",4]]],[10,"deserialize_map","","Hint that the `Deserialize` type is expecting a map of…",11,[[],["result",4]]],[10,"deserialize_struct","","Hint that the `Deserialize` type is expecting a struct…",11,[[],["result",4]]],[10,"deserialize_enum","","Hint that the `Deserialize` type is expecting an enum…",11,[[],["result",4]]],[10,"deserialize_identifier","","Hint that the `Deserialize` type is expecting the name of…",11,[[],["result",4]]],[10,"deserialize_ignored_any","","Hint that the `Deserialize` type needs to deserialize a…",11,[[],["result",4]]],[11,"is_human_readable","","Determine whether `Deserialize` implementations should…",11,[[]]],[8,"Serialize","","A data structure that can be serialized into any data…",null,null],[10,"serialize","","Serialize this value into the given Serde serializer.",19,[[],["result",4]]],[8,"Serializer","","A data format that can serialize any data structure…",null,null],[16,"Ok","","The output type produced by this `Serializer` during…",20,null],[16,"Error","","The error type when some error occurs during serialization.",20,null],[16,"SerializeSeq","","Type returned from [`serialize_seq`] for serializing the…",20,null],[16,"SerializeTuple","","Type returned from [`serialize_tuple`] for serializing the…",20,null],[16,"SerializeTupleStruct","","Type returned from [`serialize_tuple_struct`] for…",20,null],[16,"SerializeTupleVariant","","Type returned from [`serialize_tuple_variant`] for…",20,null],[16,"SerializeMap","","Type returned from [`serialize_map`] for serializing the…",20,null],[16,"SerializeStruct","","Type returned from [`serialize_struct`] for serializing…",20,null],[16,"SerializeStructVariant","","Type returned from [`serialize_struct_variant`] for…",20,null],[10,"serialize_bool","","Serialize a `bool` value.",20,[[],["result",4]]],[10,"serialize_i8","","Serialize an `i8` value.",20,[[],["result",4]]],[10,"serialize_i16","","Serialize an `i16` value.",20,[[],["result",4]]],[10,"serialize_i32","","Serialize an `i32` value.",20,[[],["result",4]]],[10,"serialize_i64","","Serialize an `i64` value.",20,[[],["result",4]]],[11,"serialize_i128","","Serialize an `i128` value.",20,[[],["result",4]]],[10,"serialize_u8","","Serialize a `u8` value.",20,[[],["result",4]]],[10,"serialize_u16","","Serialize a `u16` value.",20,[[],["result",4]]],[10,"serialize_u32","","Serialize a `u32` value.",20,[[],["result",4]]],[10,"serialize_u64","","Serialize a `u64` value.",20,[[],["result",4]]],[11,"serialize_u128","","Serialize a `u128` value.",20,[[],["result",4]]],[10,"serialize_f32","","Serialize an `f32` value.",20,[[],["result",4]]],[10,"serialize_f64","","Serialize an `f64` value.",20,[[],["result",4]]],[10,"serialize_char","","Serialize a character.",20,[[],["result",4]]],[10,"serialize_str","","Serialize a `&str`.",20,[[],["result",4]]],[10,"serialize_bytes","","Serialize a chunk of raw byte data.",20,[[],["result",4]]],[10,"serialize_none","","Serialize a [`None`] value.",20,[[],["result",4]]],[10,"serialize_some","","Serialize a [`Some(T)`] value.",20,[[],["result",4]]],[10,"serialize_unit","","Serialize a `()` value.",20,[[],["result",4]]],[10,"serialize_unit_struct","","Serialize a unit struct like `struct Unit` or…",20,[[],["result",4]]],[10,"serialize_unit_variant","","Serialize a unit variant like `E::A` in `enum E { A, B }`.",20,[[],["result",4]]],[10,"serialize_newtype_struct","","Serialize a newtype struct like `struct Millimeters(u8)`.",20,[[],["result",4]]],[10,"serialize_newtype_variant","","Serialize a newtype variant like `E::N` in `enum E { N(u8)…",20,[[],["result",4]]],[10,"serialize_seq","","Begin to serialize a variably sized sequence. This call…",20,[[["option",4]],["result",4]]],[10,"serialize_tuple","","Begin to serialize a statically sized sequence whose…",20,[[],["result",4]]],[10,"serialize_tuple_struct","","Begin to serialize a tuple struct like `struct Rgb(u8, u8,…",20,[[],["result",4]]],[10,"serialize_tuple_variant","","Begin to serialize a tuple variant like `E::T` in `enum E…",20,[[],["result",4]]],[10,"serialize_map","","Begin to serialize a map. This call must be followed by…",20,[[["option",4]],["result",4]]],[10,"serialize_struct","","Begin to serialize a struct like `struct Rgb { r: u8, g:…",20,[[],["result",4]]],[10,"serialize_struct_variant","","Begin to serialize a struct variant like `E::S` in `enum E…",20,[[],["result",4]]],[11,"collect_seq","","Collect an iterator as a sequence.",20,[[],["result",4]]],[11,"collect_map","","Collect an iterator as a map.",20,[[],["result",4]]],[11,"collect_str","","Serialize a string produced by an implementation of…",20,[[],["result",4]]],[11,"is_human_readable","","Determine whether `Serialize` implementations should…",20,[[]]],[14,"forward_to_deserialize_any","","Helper macro when implementing the `Deserializer` part of…",null,null],[14,"serde_if_integer128","","Conditional compilation depending on whether Serde is…",null,null],[11,"fmt","serde::de","",28,[[["formatter",3]],[["error",3],["result",4]]]],[11,"from","","",28,[[]]],[11,"into","","",28,[[]]],[11,"to_owned","","",28,[[]]],[11,"clone_into","","",28,[[]]],[11,"borrow","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","serde::de::value","",29,[[]]],[11,"into","","",29,[[]]],[11,"to_owned","","",29,[[]]],[11,"clone_into","","",29,[[]]],[11,"to_string","","",29,[[],["string",3]]],[11,"borrow","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"from","","",30,[[]]],[11,"into","","",30,[[]]],[11,"to_owned","","",30,[[]]],[11,"clone_into","","",30,[[]]],[11,"borrow","","",30,[[]]],[11,"try_from","","",30,[[],["result",4]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"from","","",31,[[]]],[11,"into","","",31,[[]]],[11,"to_owned","","",31,[[]]],[11,"clone_into","","",31,[[]]],[11,"borrow","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"from","","",32,[[]]],[11,"into","","",32,[[]]],[11,"to_owned","","",32,[[]]],[11,"clone_into","","",32,[[]]],[11,"borrow","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"from","","",33,[[]]],[11,"into","","",33,[[]]],[11,"to_owned","","",33,[[]]],[11,"clone_into","","",33,[[]]],[11,"borrow","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"try_into","","",33,[[],["result",4]]],[11,"borrow_mut","","",33,[[]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"from","","",34,[[]]],[11,"into","","",34,[[]]],[11,"to_owned","","",34,[[]]],[11,"clone_into","","",34,[[]]],[11,"borrow","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"try_into","","",34,[[],["result",4]]],[11,"borrow_mut","","",34,[[]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"from","","",35,[[]]],[11,"into","","",35,[[]]],[11,"to_owned","","",35,[[]]],[11,"clone_into","","",35,[[]]],[11,"borrow","","",35,[[]]],[11,"try_from","","",35,[[],["result",4]]],[11,"try_into","","",35,[[],["result",4]]],[11,"borrow_mut","","",35,[[]]],[11,"type_id","","",35,[[],["typeid",3]]],[11,"from","","",36,[[]]],[11,"into","","",36,[[]]],[11,"to_owned","","",36,[[]]],[11,"clone_into","","",36,[[]]],[11,"borrow","","",36,[[]]],[11,"try_from","","",36,[[],["result",4]]],[11,"try_into","","",36,[[],["result",4]]],[11,"borrow_mut","","",36,[[]]],[11,"type_id","","",36,[[],["typeid",3]]],[11,"from","","",37,[[]]],[11,"into","","",37,[[]]],[11,"to_owned","","",37,[[]]],[11,"clone_into","","",37,[[]]],[11,"borrow","","",37,[[]]],[11,"try_from","","",37,[[],["result",4]]],[11,"try_into","","",37,[[],["result",4]]],[11,"borrow_mut","","",37,[[]]],[11,"type_id","","",37,[[],["typeid",3]]],[11,"from","","",38,[[]]],[11,"into","","",38,[[]]],[11,"to_owned","","",38,[[]]],[11,"clone_into","","",38,[[]]],[11,"borrow","","",38,[[]]],[11,"try_from","","",38,[[],["result",4]]],[11,"try_into","","",38,[[],["result",4]]],[11,"borrow_mut","","",38,[[]]],[11,"type_id","","",38,[[],["typeid",3]]],[11,"from","","",39,[[]]],[11,"into","","",39,[[]]],[11,"to_owned","","",39,[[]]],[11,"clone_into","","",39,[[]]],[11,"borrow","","",39,[[]]],[11,"try_from","","",39,[[],["result",4]]],[11,"try_into","","",39,[[],["result",4]]],[11,"borrow_mut","","",39,[[]]],[11,"type_id","","",39,[[],["typeid",3]]],[11,"from","","",40,[[]]],[11,"into","","",40,[[]]],[11,"to_owned","","",40,[[]]],[11,"clone_into","","",40,[[]]],[11,"borrow","","",40,[[]]],[11,"try_from","","",40,[[],["result",4]]],[11,"try_into","","",40,[[],["result",4]]],[11,"borrow_mut","","",40,[[]]],[11,"type_id","","",40,[[],["typeid",3]]],[11,"from","","",41,[[]]],[11,"into","","",41,[[]]],[11,"to_owned","","",41,[[]]],[11,"clone_into","","",41,[[]]],[11,"borrow","","",41,[[]]],[11,"try_from","","",41,[[],["result",4]]],[11,"try_into","","",41,[[],["result",4]]],[11,"borrow_mut","","",41,[[]]],[11,"type_id","","",41,[[],["typeid",3]]],[11,"from","","",42,[[]]],[11,"into","","",42,[[]]],[11,"to_owned","","",42,[[]]],[11,"clone_into","","",42,[[]]],[11,"borrow","","",42,[[]]],[11,"try_from","","",42,[[],["result",4]]],[11,"try_into","","",42,[[],["result",4]]],[11,"borrow_mut","","",42,[[]]],[11,"type_id","","",42,[[],["typeid",3]]],[11,"from","","",43,[[]]],[11,"into","","",43,[[]]],[11,"to_owned","","",43,[[]]],[11,"clone_into","","",43,[[]]],[11,"borrow","","",43,[[]]],[11,"try_from","","",43,[[],["result",4]]],[11,"try_into","","",43,[[],["result",4]]],[11,"borrow_mut","","",43,[[]]],[11,"type_id","","",43,[[],["typeid",3]]],[11,"from","","",44,[[]]],[11,"into","","",44,[[]]],[11,"to_owned","","",44,[[]]],[11,"clone_into","","",44,[[]]],[11,"borrow","","",44,[[]]],[11,"try_from","","",44,[[],["result",4]]],[11,"try_into","","",44,[[],["result",4]]],[11,"borrow_mut","","",44,[[]]],[11,"type_id","","",44,[[],["typeid",3]]],[11,"from","","",45,[[]]],[11,"into","","",45,[[]]],[11,"to_owned","","",45,[[]]],[11,"clone_into","","",45,[[]]],[11,"borrow","","",45,[[]]],[11,"try_from","","",45,[[],["result",4]]],[11,"try_into","","",45,[[],["result",4]]],[11,"borrow_mut","","",45,[[]]],[11,"type_id","","",45,[[],["typeid",3]]],[11,"from","","",46,[[]]],[11,"into","","",46,[[]]],[11,"to_owned","","",46,[[]]],[11,"clone_into","","",46,[[]]],[11,"borrow","","",46,[[]]],[11,"try_from","","",46,[[],["result",4]]],[11,"try_into","","",46,[[],["result",4]]],[11,"borrow_mut","","",46,[[]]],[11,"type_id","","",46,[[],["typeid",3]]],[11,"from","","",47,[[]]],[11,"into","","",47,[[]]],[11,"to_owned","","",47,[[]]],[11,"clone_into","","",47,[[]]],[11,"borrow","","",47,[[]]],[11,"try_from","","",47,[[],["result",4]]],[11,"try_into","","",47,[[],["result",4]]],[11,"borrow_mut","","",47,[[]]],[11,"type_id","","",47,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",48,[[]]],[11,"into","","",48,[[]]],[11,"to_owned","","",48,[[]]],[11,"clone_into","","",48,[[]]],[11,"borrow","","",48,[[]]],[11,"try_from","","",48,[[],["result",4]]],[11,"try_into","","",48,[[],["result",4]]],[11,"borrow_mut","","",48,[[]]],[11,"type_id","","",48,[[],["typeid",3]]],[11,"from","","",49,[[]]],[11,"into","","",49,[[]]],[11,"to_owned","","",49,[[]]],[11,"clone_into","","",49,[[]]],[11,"borrow","","",49,[[]]],[11,"try_from","","",49,[[],["result",4]]],[11,"try_into","","",49,[[],["result",4]]],[11,"borrow_mut","","",49,[[]]],[11,"type_id","","",49,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","serde::ser","",50,[[]]],[11,"into","","",50,[[]]],[11,"borrow","","",50,[[]]],[11,"try_from","","",50,[[],["result",4]]],[11,"try_into","","",50,[[],["result",4]]],[11,"borrow_mut","","",50,[[]]],[11,"type_id","","",50,[[],["typeid",3]]],[11,"deserialize","serde::de","",28,[[],[["result",4],["ignoredany",3]]]],[11,"deserialize_bool","serde::de::value","",30,[[],["result",4]]],[11,"deserialize_i8","","",30,[[],["result",4]]],[11,"deserialize_i16","","",30,[[],["result",4]]],[11,"deserialize_i32","","",30,[[],["result",4]]],[11,"deserialize_i64","","",30,[[],["result",4]]],[11,"deserialize_i128","","",30,[[],["result",4]]],[11,"deserialize_u8","","",30,[[],["result",4]]],[11,"deserialize_u16","","",30,[[],["result",4]]],[11,"deserialize_u32","","",30,[[],["result",4]]],[11,"deserialize_u64","","",30,[[],["result",4]]],[11,"deserialize_u128","","",30,[[],["result",4]]],[11,"deserialize_f32","","",30,[[],["result",4]]],[11,"deserialize_f64","","",30,[[],["result",4]]],[11,"deserialize_char","","",30,[[],["result",4]]],[11,"deserialize_str","","",30,[[],["result",4]]],[11,"deserialize_string","","",30,[[],["result",4]]],[11,"deserialize_bytes","","",30,[[],["result",4]]],[11,"deserialize_byte_buf","","",30,[[],["result",4]]],[11,"deserialize_unit","","",30,[[],["result",4]]],[11,"deserialize_unit_struct","","",30,[[],["result",4]]],[11,"deserialize_newtype_struct","","",30,[[],["result",4]]],[11,"deserialize_seq","","",30,[[],["result",4]]],[11,"deserialize_tuple","","",30,[[],["result",4]]],[11,"deserialize_tuple_struct","","",30,[[],["result",4]]],[11,"deserialize_map","","",30,[[],["result",4]]],[11,"deserialize_struct","","",30,[[],["result",4]]],[11,"deserialize_enum","","",30,[[],["result",4]]],[11,"deserialize_identifier","","",30,[[],["result",4]]],[11,"deserialize_ignored_any","","",30,[[],["result",4]]],[11,"deserialize_any","","",30,[[],["result",4]]],[11,"deserialize_option","","",30,[[],["result",4]]],[11,"deserialize_bool","","",31,[[],["result",4]]],[11,"deserialize_i8","","",31,[[],["result",4]]],[11,"deserialize_i16","","",31,[[],["result",4]]],[11,"deserialize_i32","","",31,[[],["result",4]]],[11,"deserialize_i64","","",31,[[],["result",4]]],[11,"deserialize_i128","","",31,[[],["result",4]]],[11,"deserialize_u8","","",31,[[],["result",4]]],[11,"deserialize_u16","","",31,[[],["result",4]]],[11,"deserialize_u32","","",31,[[],["result",4]]],[11,"deserialize_u64","","",31,[[],["result",4]]],[11,"deserialize_u128","","",31,[[],["result",4]]],[11,"deserialize_f32","","",31,[[],["result",4]]],[11,"deserialize_f64","","",31,[[],["result",4]]],[11,"deserialize_char","","",31,[[],["result",4]]],[11,"deserialize_str","","",31,[[],["result",4]]],[11,"deserialize_string","","",31,[[],["result",4]]],[11,"deserialize_bytes","","",31,[[],["result",4]]],[11,"deserialize_byte_buf","","",31,[[],["result",4]]],[11,"deserialize_option","","",31,[[],["result",4]]],[11,"deserialize_unit","","",31,[[],["result",4]]],[11,"deserialize_unit_struct","","",31,[[],["result",4]]],[11,"deserialize_newtype_struct","","",31,[[],["result",4]]],[11,"deserialize_seq","","",31,[[],["result",4]]],[11,"deserialize_tuple","","",31,[[],["result",4]]],[11,"deserialize_tuple_struct","","",31,[[],["result",4]]],[11,"deserialize_map","","",31,[[],["result",4]]],[11,"deserialize_struct","","",31,[[],["result",4]]],[11,"deserialize_enum","","",31,[[],["result",4]]],[11,"deserialize_identifier","","",31,[[],["result",4]]],[11,"deserialize_ignored_any","","",31,[[],["result",4]]],[11,"deserialize_any","","",31,[[],["result",4]]],[11,"deserialize_bool","","",32,[[],["result",4]]],[11,"deserialize_i8","","",32,[[],["result",4]]],[11,"deserialize_i16","","",32,[[],["result",4]]],[11,"deserialize_i32","","",32,[[],["result",4]]],[11,"deserialize_i64","","",32,[[],["result",4]]],[11,"deserialize_i128","","",32,[[],["result",4]]],[11,"deserialize_u8","","",32,[[],["result",4]]],[11,"deserialize_u16","","",32,[[],["result",4]]],[11,"deserialize_u32","","",32,[[],["result",4]]],[11,"deserialize_u64","","",32,[[],["result",4]]],[11,"deserialize_u128","","",32,[[],["result",4]]],[11,"deserialize_f32","","",32,[[],["result",4]]],[11,"deserialize_f64","","",32,[[],["result",4]]],[11,"deserialize_char","","",32,[[],["result",4]]],[11,"deserialize_str","","",32,[[],["result",4]]],[11,"deserialize_string","","",32,[[],["result",4]]],[11,"deserialize_bytes","","",32,[[],["result",4]]],[11,"deserialize_byte_buf","","",32,[[],["result",4]]],[11,"deserialize_option","","",32,[[],["result",4]]],[11,"deserialize_unit","","",32,[[],["result",4]]],[11,"deserialize_unit_struct","","",32,[[],["result",4]]],[11,"deserialize_newtype_struct","","",32,[[],["result",4]]],[11,"deserialize_seq","","",32,[[],["result",4]]],[11,"deserialize_tuple","","",32,[[],["result",4]]],[11,"deserialize_tuple_struct","","",32,[[],["result",4]]],[11,"deserialize_map","","",32,[[],["result",4]]],[11,"deserialize_struct","","",32,[[],["result",4]]],[11,"deserialize_enum","","",32,[[],["result",4]]],[11,"deserialize_identifier","","",32,[[],["result",4]]],[11,"deserialize_ignored_any","","",32,[[],["result",4]]],[11,"deserialize_any","","",32,[[],["result",4]]],[11,"deserialize_bool","","",33,[[],["result",4]]],[11,"deserialize_i8","","",33,[[],["result",4]]],[11,"deserialize_i16","","",33,[[],["result",4]]],[11,"deserialize_i32","","",33,[[],["result",4]]],[11,"deserialize_i64","","",33,[[],["result",4]]],[11,"deserialize_i128","","",33,[[],["result",4]]],[11,"deserialize_u8","","",33,[[],["result",4]]],[11,"deserialize_u16","","",33,[[],["result",4]]],[11,"deserialize_u32","","",33,[[],["result",4]]],[11,"deserialize_u64","","",33,[[],["result",4]]],[11,"deserialize_u128","","",33,[[],["result",4]]],[11,"deserialize_f32","","",33,[[],["result",4]]],[11,"deserialize_f64","","",33,[[],["result",4]]],[11,"deserialize_char","","",33,[[],["result",4]]],[11,"deserialize_str","","",33,[[],["result",4]]],[11,"deserialize_string","","",33,[[],["result",4]]],[11,"deserialize_bytes","","",33,[[],["result",4]]],[11,"deserialize_byte_buf","","",33,[[],["result",4]]],[11,"deserialize_option","","",33,[[],["result",4]]],[11,"deserialize_unit","","",33,[[],["result",4]]],[11,"deserialize_unit_struct","","",33,[[],["result",4]]],[11,"deserialize_newtype_struct","","",33,[[],["result",4]]],[11,"deserialize_seq","","",33,[[],["result",4]]],[11,"deserialize_tuple","","",33,[[],["result",4]]],[11,"deserialize_tuple_struct","","",33,[[],["result",4]]],[11,"deserialize_map","","",33,[[],["result",4]]],[11,"deserialize_struct","","",33,[[],["result",4]]],[11,"deserialize_enum","","",33,[[],["result",4]]],[11,"deserialize_identifier","","",33,[[],["result",4]]],[11,"deserialize_ignored_any","","",33,[[],["result",4]]],[11,"deserialize_any","","",33,[[],["result",4]]],[11,"deserialize_bool","","",34,[[],["result",4]]],[11,"deserialize_i8","","",34,[[],["result",4]]],[11,"deserialize_i16","","",34,[[],["result",4]]],[11,"deserialize_i32","","",34,[[],["result",4]]],[11,"deserialize_i64","","",34,[[],["result",4]]],[11,"deserialize_i128","","",34,[[],["result",4]]],[11,"deserialize_u8","","",34,[[],["result",4]]],[11,"deserialize_u16","","",34,[[],["result",4]]],[11,"deserialize_u32","","",34,[[],["result",4]]],[11,"deserialize_u64","","",34,[[],["result",4]]],[11,"deserialize_u128","","",34,[[],["result",4]]],[11,"deserialize_f32","","",34,[[],["result",4]]],[11,"deserialize_f64","","",34,[[],["result",4]]],[11,"deserialize_char","","",34,[[],["result",4]]],[11,"deserialize_str","","",34,[[],["result",4]]],[11,"deserialize_string","","",34,[[],["result",4]]],[11,"deserialize_bytes","","",34,[[],["result",4]]],[11,"deserialize_byte_buf","","",34,[[],["result",4]]],[11,"deserialize_option","","",34,[[],["result",4]]],[11,"deserialize_unit","","",34,[[],["result",4]]],[11,"deserialize_unit_struct","","",34,[[],["result",4]]],[11,"deserialize_newtype_struct","","",34,[[],["result",4]]],[11,"deserialize_seq","","",34,[[],["result",4]]],[11,"deserialize_tuple","","",34,[[],["result",4]]],[11,"deserialize_tuple_struct","","",34,[[],["result",4]]],[11,"deserialize_map","","",34,[[],["result",4]]],[11,"deserialize_struct","","",34,[[],["result",4]]],[11,"deserialize_enum","","",34,[[],["result",4]]],[11,"deserialize_identifier","","",34,[[],["result",4]]],[11,"deserialize_ignored_any","","",34,[[],["result",4]]],[11,"deserialize_any","","",34,[[],["result",4]]],[11,"deserialize_bool","","",35,[[],["result",4]]],[11,"deserialize_i8","","",35,[[],["result",4]]],[11,"deserialize_i16","","",35,[[],["result",4]]],[11,"deserialize_i32","","",35,[[],["result",4]]],[11,"deserialize_i64","","",35,[[],["result",4]]],[11,"deserialize_i128","","",35,[[],["result",4]]],[11,"deserialize_u8","","",35,[[],["result",4]]],[11,"deserialize_u16","","",35,[[],["result",4]]],[11,"deserialize_u32","","",35,[[],["result",4]]],[11,"deserialize_u64","","",35,[[],["result",4]]],[11,"deserialize_u128","","",35,[[],["result",4]]],[11,"deserialize_f32","","",35,[[],["result",4]]],[11,"deserialize_f64","","",35,[[],["result",4]]],[11,"deserialize_char","","",35,[[],["result",4]]],[11,"deserialize_str","","",35,[[],["result",4]]],[11,"deserialize_string","","",35,[[],["result",4]]],[11,"deserialize_bytes","","",35,[[],["result",4]]],[11,"deserialize_byte_buf","","",35,[[],["result",4]]],[11,"deserialize_option","","",35,[[],["result",4]]],[11,"deserialize_unit","","",35,[[],["result",4]]],[11,"deserialize_unit_struct","","",35,[[],["result",4]]],[11,"deserialize_newtype_struct","","",35,[[],["result",4]]],[11,"deserialize_seq","","",35,[[],["result",4]]],[11,"deserialize_tuple","","",35,[[],["result",4]]],[11,"deserialize_tuple_struct","","",35,[[],["result",4]]],[11,"deserialize_map","","",35,[[],["result",4]]],[11,"deserialize_struct","","",35,[[],["result",4]]],[11,"deserialize_enum","","",35,[[],["result",4]]],[11,"deserialize_identifier","","",35,[[],["result",4]]],[11,"deserialize_ignored_any","","",35,[[],["result",4]]],[11,"deserialize_any","","",35,[[],["result",4]]],[11,"deserialize_bool","","",36,[[],["result",4]]],[11,"deserialize_i8","","",36,[[],["result",4]]],[11,"deserialize_i16","","",36,[[],["result",4]]],[11,"deserialize_i32","","",36,[[],["result",4]]],[11,"deserialize_i64","","",36,[[],["result",4]]],[11,"deserialize_i128","","",36,[[],["result",4]]],[11,"deserialize_u8","","",36,[[],["result",4]]],[11,"deserialize_u16","","",36,[[],["result",4]]],[11,"deserialize_u32","","",36,[[],["result",4]]],[11,"deserialize_u64","","",36,[[],["result",4]]],[11,"deserialize_u128","","",36,[[],["result",4]]],[11,"deserialize_f32","","",36,[[],["result",4]]],[11,"deserialize_f64","","",36,[[],["result",4]]],[11,"deserialize_char","","",36,[[],["result",4]]],[11,"deserialize_str","","",36,[[],["result",4]]],[11,"deserialize_string","","",36,[[],["result",4]]],[11,"deserialize_bytes","","",36,[[],["result",4]]],[11,"deserialize_byte_buf","","",36,[[],["result",4]]],[11,"deserialize_option","","",36,[[],["result",4]]],[11,"deserialize_unit","","",36,[[],["result",4]]],[11,"deserialize_unit_struct","","",36,[[],["result",4]]],[11,"deserialize_newtype_struct","","",36,[[],["result",4]]],[11,"deserialize_seq","","",36,[[],["result",4]]],[11,"deserialize_tuple","","",36,[[],["result",4]]],[11,"deserialize_tuple_struct","","",36,[[],["result",4]]],[11,"deserialize_map","","",36,[[],["result",4]]],[11,"deserialize_struct","","",36,[[],["result",4]]],[11,"deserialize_enum","","",36,[[],["result",4]]],[11,"deserialize_identifier","","",36,[[],["result",4]]],[11,"deserialize_ignored_any","","",36,[[],["result",4]]],[11,"deserialize_any","","",36,[[],["result",4]]],[11,"deserialize_bool","","",37,[[],["result",4]]],[11,"deserialize_i8","","",37,[[],["result",4]]],[11,"deserialize_i16","","",37,[[],["result",4]]],[11,"deserialize_i32","","",37,[[],["result",4]]],[11,"deserialize_i64","","",37,[[],["result",4]]],[11,"deserialize_i128","","",37,[[],["result",4]]],[11,"deserialize_u8","","",37,[[],["result",4]]],[11,"deserialize_u16","","",37,[[],["result",4]]],[11,"deserialize_u32","","",37,[[],["result",4]]],[11,"deserialize_u64","","",37,[[],["result",4]]],[11,"deserialize_u128","","",37,[[],["result",4]]],[11,"deserialize_f32","","",37,[[],["result",4]]],[11,"deserialize_f64","","",37,[[],["result",4]]],[11,"deserialize_char","","",37,[[],["result",4]]],[11,"deserialize_str","","",37,[[],["result",4]]],[11,"deserialize_string","","",37,[[],["result",4]]],[11,"deserialize_bytes","","",37,[[],["result",4]]],[11,"deserialize_byte_buf","","",37,[[],["result",4]]],[11,"deserialize_option","","",37,[[],["result",4]]],[11,"deserialize_unit","","",37,[[],["result",4]]],[11,"deserialize_unit_struct","","",37,[[],["result",4]]],[11,"deserialize_newtype_struct","","",37,[[],["result",4]]],[11,"deserialize_seq","","",37,[[],["result",4]]],[11,"deserialize_tuple","","",37,[[],["result",4]]],[11,"deserialize_tuple_struct","","",37,[[],["result",4]]],[11,"deserialize_map","","",37,[[],["result",4]]],[11,"deserialize_struct","","",37,[[],["result",4]]],[11,"deserialize_enum","","",37,[[],["result",4]]],[11,"deserialize_identifier","","",37,[[],["result",4]]],[11,"deserialize_ignored_any","","",37,[[],["result",4]]],[11,"deserialize_any","","",37,[[],["result",4]]],[11,"deserialize_bool","","",38,[[],["result",4]]],[11,"deserialize_i8","","",38,[[],["result",4]]],[11,"deserialize_i16","","",38,[[],["result",4]]],[11,"deserialize_i32","","",38,[[],["result",4]]],[11,"deserialize_i64","","",38,[[],["result",4]]],[11,"deserialize_i128","","",38,[[],["result",4]]],[11,"deserialize_u8","","",38,[[],["result",4]]],[11,"deserialize_u16","","",38,[[],["result",4]]],[11,"deserialize_u32","","",38,[[],["result",4]]],[11,"deserialize_u64","","",38,[[],["result",4]]],[11,"deserialize_u128","","",38,[[],["result",4]]],[11,"deserialize_f32","","",38,[[],["result",4]]],[11,"deserialize_f64","","",38,[[],["result",4]]],[11,"deserialize_char","","",38,[[],["result",4]]],[11,"deserialize_str","","",38,[[],["result",4]]],[11,"deserialize_string","","",38,[[],["result",4]]],[11,"deserialize_bytes","","",38,[[],["result",4]]],[11,"deserialize_byte_buf","","",38,[[],["result",4]]],[11,"deserialize_option","","",38,[[],["result",4]]],[11,"deserialize_unit","","",38,[[],["result",4]]],[11,"deserialize_unit_struct","","",38,[[],["result",4]]],[11,"deserialize_newtype_struct","","",38,[[],["result",4]]],[11,"deserialize_seq","","",38,[[],["result",4]]],[11,"deserialize_tuple","","",38,[[],["result",4]]],[11,"deserialize_tuple_struct","","",38,[[],["result",4]]],[11,"deserialize_map","","",38,[[],["result",4]]],[11,"deserialize_struct","","",38,[[],["result",4]]],[11,"deserialize_enum","","",38,[[],["result",4]]],[11,"deserialize_identifier","","",38,[[],["result",4]]],[11,"deserialize_ignored_any","","",38,[[],["result",4]]],[11,"deserialize_any","","",38,[[],["result",4]]],[11,"deserialize_bool","","",39,[[],["result",4]]],[11,"deserialize_i8","","",39,[[],["result",4]]],[11,"deserialize_i16","","",39,[[],["result",4]]],[11,"deserialize_i32","","",39,[[],["result",4]]],[11,"deserialize_i64","","",39,[[],["result",4]]],[11,"deserialize_i128","","",39,[[],["result",4]]],[11,"deserialize_u8","","",39,[[],["result",4]]],[11,"deserialize_u16","","",39,[[],["result",4]]],[11,"deserialize_u32","","",39,[[],["result",4]]],[11,"deserialize_u64","","",39,[[],["result",4]]],[11,"deserialize_u128","","",39,[[],["result",4]]],[11,"deserialize_f32","","",39,[[],["result",4]]],[11,"deserialize_f64","","",39,[[],["result",4]]],[11,"deserialize_char","","",39,[[],["result",4]]],[11,"deserialize_str","","",39,[[],["result",4]]],[11,"deserialize_string","","",39,[[],["result",4]]],[11,"deserialize_bytes","","",39,[[],["result",4]]],[11,"deserialize_byte_buf","","",39,[[],["result",4]]],[11,"deserialize_option","","",39,[[],["result",4]]],[11,"deserialize_unit","","",39,[[],["result",4]]],[11,"deserialize_unit_struct","","",39,[[],["result",4]]],[11,"deserialize_newtype_struct","","",39,[[],["result",4]]],[11,"deserialize_seq","","",39,[[],["result",4]]],[11,"deserialize_tuple","","",39,[[],["result",4]]],[11,"deserialize_tuple_struct","","",39,[[],["result",4]]],[11,"deserialize_map","","",39,[[],["result",4]]],[11,"deserialize_struct","","",39,[[],["result",4]]],[11,"deserialize_enum","","",39,[[],["result",4]]],[11,"deserialize_identifier","","",39,[[],["result",4]]],[11,"deserialize_ignored_any","","",39,[[],["result",4]]],[11,"deserialize_any","","",39,[[],["result",4]]],[11,"deserialize_bool","","",40,[[],["result",4]]],[11,"deserialize_i8","","",40,[[],["result",4]]],[11,"deserialize_i16","","",40,[[],["result",4]]],[11,"deserialize_i32","","",40,[[],["result",4]]],[11,"deserialize_i64","","",40,[[],["result",4]]],[11,"deserialize_i128","","",40,[[],["result",4]]],[11,"deserialize_u8","","",40,[[],["result",4]]],[11,"deserialize_u16","","",40,[[],["result",4]]],[11,"deserialize_u32","","",40,[[],["result",4]]],[11,"deserialize_u64","","",40,[[],["result",4]]],[11,"deserialize_u128","","",40,[[],["result",4]]],[11,"deserialize_f32","","",40,[[],["result",4]]],[11,"deserialize_f64","","",40,[[],["result",4]]],[11,"deserialize_char","","",40,[[],["result",4]]],[11,"deserialize_str","","",40,[[],["result",4]]],[11,"deserialize_string","","",40,[[],["result",4]]],[11,"deserialize_bytes","","",40,[[],["result",4]]],[11,"deserialize_byte_buf","","",40,[[],["result",4]]],[11,"deserialize_option","","",40,[[],["result",4]]],[11,"deserialize_unit","","",40,[[],["result",4]]],[11,"deserialize_unit_struct","","",40,[[],["result",4]]],[11,"deserialize_newtype_struct","","",40,[[],["result",4]]],[11,"deserialize_seq","","",40,[[],["result",4]]],[11,"deserialize_tuple","","",40,[[],["result",4]]],[11,"deserialize_tuple_struct","","",40,[[],["result",4]]],[11,"deserialize_map","","",40,[[],["result",4]]],[11,"deserialize_struct","","",40,[[],["result",4]]],[11,"deserialize_enum","","",40,[[],["result",4]]],[11,"deserialize_identifier","","",40,[[],["result",4]]],[11,"deserialize_ignored_any","","",40,[[],["result",4]]],[11,"deserialize_any","","",40,[[],["result",4]]],[11,"deserialize_bool","","",41,[[],["result",4]]],[11,"deserialize_i8","","",41,[[],["result",4]]],[11,"deserialize_i16","","",41,[[],["result",4]]],[11,"deserialize_i32","","",41,[[],["result",4]]],[11,"deserialize_i64","","",41,[[],["result",4]]],[11,"deserialize_i128","","",41,[[],["result",4]]],[11,"deserialize_u8","","",41,[[],["result",4]]],[11,"deserialize_u16","","",41,[[],["result",4]]],[11,"deserialize_u32","","",41,[[],["result",4]]],[11,"deserialize_u64","","",41,[[],["result",4]]],[11,"deserialize_u128","","",41,[[],["result",4]]],[11,"deserialize_f32","","",41,[[],["result",4]]],[11,"deserialize_f64","","",41,[[],["result",4]]],[11,"deserialize_char","","",41,[[],["result",4]]],[11,"deserialize_str","","",41,[[],["result",4]]],[11,"deserialize_string","","",41,[[],["result",4]]],[11,"deserialize_bytes","","",41,[[],["result",4]]],[11,"deserialize_byte_buf","","",41,[[],["result",4]]],[11,"deserialize_option","","",41,[[],["result",4]]],[11,"deserialize_unit","","",41,[[],["result",4]]],[11,"deserialize_unit_struct","","",41,[[],["result",4]]],[11,"deserialize_newtype_struct","","",41,[[],["result",4]]],[11,"deserialize_seq","","",41,[[],["result",4]]],[11,"deserialize_tuple","","",41,[[],["result",4]]],[11,"deserialize_tuple_struct","","",41,[[],["result",4]]],[11,"deserialize_map","","",41,[[],["result",4]]],[11,"deserialize_struct","","",41,[[],["result",4]]],[11,"deserialize_enum","","",41,[[],["result",4]]],[11,"deserialize_identifier","","",41,[[],["result",4]]],[11,"deserialize_ignored_any","","",41,[[],["result",4]]],[11,"deserialize_any","","",41,[[],["result",4]]],[11,"deserialize_bool","","",42,[[],["result",4]]],[11,"deserialize_i8","","",42,[[],["result",4]]],[11,"deserialize_i16","","",42,[[],["result",4]]],[11,"deserialize_i32","","",42,[[],["result",4]]],[11,"deserialize_i64","","",42,[[],["result",4]]],[11,"deserialize_i128","","",42,[[],["result",4]]],[11,"deserialize_u8","","",42,[[],["result",4]]],[11,"deserialize_u16","","",42,[[],["result",4]]],[11,"deserialize_u32","","",42,[[],["result",4]]],[11,"deserialize_u64","","",42,[[],["result",4]]],[11,"deserialize_u128","","",42,[[],["result",4]]],[11,"deserialize_f32","","",42,[[],["result",4]]],[11,"deserialize_f64","","",42,[[],["result",4]]],[11,"deserialize_char","","",42,[[],["result",4]]],[11,"deserialize_str","","",42,[[],["result",4]]],[11,"deserialize_string","","",42,[[],["result",4]]],[11,"deserialize_bytes","","",42,[[],["result",4]]],[11,"deserialize_byte_buf","","",42,[[],["result",4]]],[11,"deserialize_option","","",42,[[],["result",4]]],[11,"deserialize_unit","","",42,[[],["result",4]]],[11,"deserialize_unit_struct","","",42,[[],["result",4]]],[11,"deserialize_newtype_struct","","",42,[[],["result",4]]],[11,"deserialize_seq","","",42,[[],["result",4]]],[11,"deserialize_tuple","","",42,[[],["result",4]]],[11,"deserialize_tuple_struct","","",42,[[],["result",4]]],[11,"deserialize_map","","",42,[[],["result",4]]],[11,"deserialize_struct","","",42,[[],["result",4]]],[11,"deserialize_enum","","",42,[[],["result",4]]],[11,"deserialize_identifier","","",42,[[],["result",4]]],[11,"deserialize_ignored_any","","",42,[[],["result",4]]],[11,"deserialize_any","","",42,[[],["result",4]]],[11,"deserialize_bool","","",43,[[],["result",4]]],[11,"deserialize_i8","","",43,[[],["result",4]]],[11,"deserialize_i16","","",43,[[],["result",4]]],[11,"deserialize_i32","","",43,[[],["result",4]]],[11,"deserialize_i64","","",43,[[],["result",4]]],[11,"deserialize_i128","","",43,[[],["result",4]]],[11,"deserialize_u8","","",43,[[],["result",4]]],[11,"deserialize_u16","","",43,[[],["result",4]]],[11,"deserialize_u32","","",43,[[],["result",4]]],[11,"deserialize_u64","","",43,[[],["result",4]]],[11,"deserialize_u128","","",43,[[],["result",4]]],[11,"deserialize_f32","","",43,[[],["result",4]]],[11,"deserialize_f64","","",43,[[],["result",4]]],[11,"deserialize_char","","",43,[[],["result",4]]],[11,"deserialize_str","","",43,[[],["result",4]]],[11,"deserialize_string","","",43,[[],["result",4]]],[11,"deserialize_bytes","","",43,[[],["result",4]]],[11,"deserialize_byte_buf","","",43,[[],["result",4]]],[11,"deserialize_option","","",43,[[],["result",4]]],[11,"deserialize_unit","","",43,[[],["result",4]]],[11,"deserialize_unit_struct","","",43,[[],["result",4]]],[11,"deserialize_newtype_struct","","",43,[[],["result",4]]],[11,"deserialize_seq","","",43,[[],["result",4]]],[11,"deserialize_tuple","","",43,[[],["result",4]]],[11,"deserialize_tuple_struct","","",43,[[],["result",4]]],[11,"deserialize_map","","",43,[[],["result",4]]],[11,"deserialize_struct","","",43,[[],["result",4]]],[11,"deserialize_enum","","",43,[[],["result",4]]],[11,"deserialize_identifier","","",43,[[],["result",4]]],[11,"deserialize_ignored_any","","",43,[[],["result",4]]],[11,"deserialize_any","","",43,[[],["result",4]]],[11,"deserialize_bool","","",44,[[],["result",4]]],[11,"deserialize_i8","","",44,[[],["result",4]]],[11,"deserialize_i16","","",44,[[],["result",4]]],[11,"deserialize_i32","","",44,[[],["result",4]]],[11,"deserialize_i64","","",44,[[],["result",4]]],[11,"deserialize_i128","","",44,[[],["result",4]]],[11,"deserialize_u8","","",44,[[],["result",4]]],[11,"deserialize_u16","","",44,[[],["result",4]]],[11,"deserialize_u32","","",44,[[],["result",4]]],[11,"deserialize_u64","","",44,[[],["result",4]]],[11,"deserialize_u128","","",44,[[],["result",4]]],[11,"deserialize_f32","","",44,[[],["result",4]]],[11,"deserialize_f64","","",44,[[],["result",4]]],[11,"deserialize_char","","",44,[[],["result",4]]],[11,"deserialize_str","","",44,[[],["result",4]]],[11,"deserialize_string","","",44,[[],["result",4]]],[11,"deserialize_bytes","","",44,[[],["result",4]]],[11,"deserialize_byte_buf","","",44,[[],["result",4]]],[11,"deserialize_option","","",44,[[],["result",4]]],[11,"deserialize_unit","","",44,[[],["result",4]]],[11,"deserialize_unit_struct","","",44,[[],["result",4]]],[11,"deserialize_newtype_struct","","",44,[[],["result",4]]],[11,"deserialize_seq","","",44,[[],["result",4]]],[11,"deserialize_tuple","","",44,[[],["result",4]]],[11,"deserialize_tuple_struct","","",44,[[],["result",4]]],[11,"deserialize_map","","",44,[[],["result",4]]],[11,"deserialize_struct","","",44,[[],["result",4]]],[11,"deserialize_enum","","",44,[[],["result",4]]],[11,"deserialize_identifier","","",44,[[],["result",4]]],[11,"deserialize_ignored_any","","",44,[[],["result",4]]],[11,"deserialize_any","","",44,[[],["result",4]]],[11,"deserialize_bool","","",45,[[],["result",4]]],[11,"deserialize_i8","","",45,[[],["result",4]]],[11,"deserialize_i16","","",45,[[],["result",4]]],[11,"deserialize_i32","","",45,[[],["result",4]]],[11,"deserialize_i64","","",45,[[],["result",4]]],[11,"deserialize_i128","","",45,[[],["result",4]]],[11,"deserialize_u8","","",45,[[],["result",4]]],[11,"deserialize_u16","","",45,[[],["result",4]]],[11,"deserialize_u32","","",45,[[],["result",4]]],[11,"deserialize_u64","","",45,[[],["result",4]]],[11,"deserialize_u128","","",45,[[],["result",4]]],[11,"deserialize_f32","","",45,[[],["result",4]]],[11,"deserialize_f64","","",45,[[],["result",4]]],[11,"deserialize_char","","",45,[[],["result",4]]],[11,"deserialize_str","","",45,[[],["result",4]]],[11,"deserialize_string","","",45,[[],["result",4]]],[11,"deserialize_bytes","","",45,[[],["result",4]]],[11,"deserialize_byte_buf","","",45,[[],["result",4]]],[11,"deserialize_option","","",45,[[],["result",4]]],[11,"deserialize_unit","","",45,[[],["result",4]]],[11,"deserialize_unit_struct","","",45,[[],["result",4]]],[11,"deserialize_newtype_struct","","",45,[[],["result",4]]],[11,"deserialize_seq","","",45,[[],["result",4]]],[11,"deserialize_tuple","","",45,[[],["result",4]]],[11,"deserialize_tuple_struct","","",45,[[],["result",4]]],[11,"deserialize_map","","",45,[[],["result",4]]],[11,"deserialize_struct","","",45,[[],["result",4]]],[11,"deserialize_enum","","",45,[[],["result",4]]],[11,"deserialize_identifier","","",45,[[],["result",4]]],[11,"deserialize_ignored_any","","",45,[[],["result",4]]],[11,"deserialize_any","","",45,[[],["result",4]]],[11,"deserialize_bool","","",46,[[],["result",4]]],[11,"deserialize_i8","","",46,[[],["result",4]]],[11,"deserialize_i16","","",46,[[],["result",4]]],[11,"deserialize_i32","","",46,[[],["result",4]]],[11,"deserialize_i64","","",46,[[],["result",4]]],[11,"deserialize_i128","","",46,[[],["result",4]]],[11,"deserialize_u8","","",46,[[],["result",4]]],[11,"deserialize_u16","","",46,[[],["result",4]]],[11,"deserialize_u32","","",46,[[],["result",4]]],[11,"deserialize_u64","","",46,[[],["result",4]]],[11,"deserialize_u128","","",46,[[],["result",4]]],[11,"deserialize_f32","","",46,[[],["result",4]]],[11,"deserialize_f64","","",46,[[],["result",4]]],[11,"deserialize_char","","",46,[[],["result",4]]],[11,"deserialize_str","","",46,[[],["result",4]]],[11,"deserialize_string","","",46,[[],["result",4]]],[11,"deserialize_bytes","","",46,[[],["result",4]]],[11,"deserialize_byte_buf","","",46,[[],["result",4]]],[11,"deserialize_option","","",46,[[],["result",4]]],[11,"deserialize_unit","","",46,[[],["result",4]]],[11,"deserialize_unit_struct","","",46,[[],["result",4]]],[11,"deserialize_newtype_struct","","",46,[[],["result",4]]],[11,"deserialize_seq","","",46,[[],["result",4]]],[11,"deserialize_tuple","","",46,[[],["result",4]]],[11,"deserialize_tuple_struct","","",46,[[],["result",4]]],[11,"deserialize_map","","",46,[[],["result",4]]],[11,"deserialize_struct","","",46,[[],["result",4]]],[11,"deserialize_identifier","","",46,[[],["result",4]]],[11,"deserialize_ignored_any","","",46,[[],["result",4]]],[11,"deserialize_any","","",46,[[],["result",4]]],[11,"deserialize_enum","","",46,[[],["result",4]]],[11,"deserialize_any","","",47,[[],["result",4]]],[11,"deserialize_enum","","",47,[[],["result",4]]],[11,"deserialize_bool","","",47,[[],["result",4]]],[11,"deserialize_i8","","",47,[[],["result",4]]],[11,"deserialize_i16","","",47,[[],["result",4]]],[11,"deserialize_i32","","",47,[[],["result",4]]],[11,"deserialize_i64","","",47,[[],["result",4]]],[11,"deserialize_i128","","",47,[[],["result",4]]],[11,"deserialize_u8","","",47,[[],["result",4]]],[11,"deserialize_u16","","",47,[[],["result",4]]],[11,"deserialize_u32","","",47,[[],["result",4]]],[11,"deserialize_u64","","",47,[[],["result",4]]],[11,"deserialize_u128","","",47,[[],["result",4]]],[11,"deserialize_f32","","",47,[[],["result",4]]],[11,"deserialize_f64","","",47,[[],["result",4]]],[11,"deserialize_char","","",47,[[],["result",4]]],[11,"deserialize_str","","",47,[[],["result",4]]],[11,"deserialize_string","","",47,[[],["result",4]]],[11,"deserialize_bytes","","",47,[[],["result",4]]],[11,"deserialize_byte_buf","","",47,[[],["result",4]]],[11,"deserialize_option","","",47,[[],["result",4]]],[11,"deserialize_unit","","",47,[[],["result",4]]],[11,"deserialize_unit_struct","","",47,[[],["result",4]]],[11,"deserialize_newtype_struct","","",47,[[],["result",4]]],[11,"deserialize_seq","","",47,[[],["result",4]]],[11,"deserialize_tuple","","",47,[[],["result",4]]],[11,"deserialize_tuple_struct","","",47,[[],["result",4]]],[11,"deserialize_map","","",47,[[],["result",4]]],[11,"deserialize_struct","","",47,[[],["result",4]]],[11,"deserialize_identifier","","",47,[[],["result",4]]],[11,"deserialize_ignored_any","","",47,[[],["result",4]]],[11,"deserialize_any","","",1,[[],["result",4]]],[11,"deserialize_enum","","",1,[[],["result",4]]],[11,"deserialize_bool","","",1,[[],["result",4]]],[11,"deserialize_i8","","",1,[[],["result",4]]],[11,"deserialize_i16","","",1,[[],["result",4]]],[11,"deserialize_i32","","",1,[[],["result",4]]],[11,"deserialize_i64","","",1,[[],["result",4]]],[11,"deserialize_i128","","",1,[[],["result",4]]],[11,"deserialize_u8","","",1,[[],["result",4]]],[11,"deserialize_u16","","",1,[[],["result",4]]],[11,"deserialize_u32","","",1,[[],["result",4]]],[11,"deserialize_u64","","",1,[[],["result",4]]],[11,"deserialize_u128","","",1,[[],["result",4]]],[11,"deserialize_f32","","",1,[[],["result",4]]],[11,"deserialize_f64","","",1,[[],["result",4]]],[11,"deserialize_char","","",1,[[],["result",4]]],[11,"deserialize_str","","",1,[[],["result",4]]],[11,"deserialize_string","","",1,[[],["result",4]]],[11,"deserialize_bytes","","",1,[[],["result",4]]],[11,"deserialize_byte_buf","","",1,[[],["result",4]]],[11,"deserialize_option","","",1,[[],["result",4]]],[11,"deserialize_unit","","",1,[[],["result",4]]],[11,"deserialize_unit_struct","","",1,[[],["result",4]]],[11,"deserialize_newtype_struct","","",1,[[],["result",4]]],[11,"deserialize_seq","","",1,[[],["result",4]]],[11,"deserialize_tuple","","",1,[[],["result",4]]],[11,"deserialize_tuple_struct","","",1,[[],["result",4]]],[11,"deserialize_map","","",1,[[],["result",4]]],[11,"deserialize_struct","","",1,[[],["result",4]]],[11,"deserialize_identifier","","",1,[[],["result",4]]],[11,"deserialize_ignored_any","","",1,[[],["result",4]]],[11,"deserialize_any","","",48,[[],["result",4]]],[11,"deserialize_enum","","",48,[[],["result",4]]],[11,"deserialize_bool","","",48,[[],["result",4]]],[11,"deserialize_i8","","",48,[[],["result",4]]],[11,"deserialize_i16","","",48,[[],["result",4]]],[11,"deserialize_i32","","",48,[[],["result",4]]],[11,"deserialize_i64","","",48,[[],["result",4]]],[11,"deserialize_i128","","",48,[[],["result",4]]],[11,"deserialize_u8","","",48,[[],["result",4]]],[11,"deserialize_u16","","",48,[[],["result",4]]],[11,"deserialize_u32","","",48,[[],["result",4]]],[11,"deserialize_u64","","",48,[[],["result",4]]],[11,"deserialize_u128","","",48,[[],["result",4]]],[11,"deserialize_f32","","",48,[[],["result",4]]],[11,"deserialize_f64","","",48,[[],["result",4]]],[11,"deserialize_char","","",48,[[],["result",4]]],[11,"deserialize_str","","",48,[[],["result",4]]],[11,"deserialize_string","","",48,[[],["result",4]]],[11,"deserialize_bytes","","",48,[[],["result",4]]],[11,"deserialize_byte_buf","","",48,[[],["result",4]]],[11,"deserialize_option","","",48,[[],["result",4]]],[11,"deserialize_unit","","",48,[[],["result",4]]],[11,"deserialize_unit_struct","","",48,[[],["result",4]]],[11,"deserialize_newtype_struct","","",48,[[],["result",4]]],[11,"deserialize_seq","","",48,[[],["result",4]]],[11,"deserialize_tuple","","",48,[[],["result",4]]],[11,"deserialize_tuple_struct","","",48,[[],["result",4]]],[11,"deserialize_map","","",48,[[],["result",4]]],[11,"deserialize_struct","","",48,[[],["result",4]]],[11,"deserialize_identifier","","",48,[[],["result",4]]],[11,"deserialize_ignored_any","","",48,[[],["result",4]]],[11,"deserialize_any","","",49,[[],["result",4]]],[11,"deserialize_enum","","",49,[[],["result",4]]],[11,"deserialize_bool","","",49,[[],["result",4]]],[11,"deserialize_i8","","",49,[[],["result",4]]],[11,"deserialize_i16","","",49,[[],["result",4]]],[11,"deserialize_i32","","",49,[[],["result",4]]],[11,"deserialize_i64","","",49,[[],["result",4]]],[11,"deserialize_i128","","",49,[[],["result",4]]],[11,"deserialize_u8","","",49,[[],["result",4]]],[11,"deserialize_u16","","",49,[[],["result",4]]],[11,"deserialize_u32","","",49,[[],["result",4]]],[11,"deserialize_u64","","",49,[[],["result",4]]],[11,"deserialize_u128","","",49,[[],["result",4]]],[11,"deserialize_f32","","",49,[[],["result",4]]],[11,"deserialize_f64","","",49,[[],["result",4]]],[11,"deserialize_char","","",49,[[],["result",4]]],[11,"deserialize_str","","",49,[[],["result",4]]],[11,"deserialize_string","","",49,[[],["result",4]]],[11,"deserialize_bytes","","",49,[[],["result",4]]],[11,"deserialize_byte_buf","","",49,[[],["result",4]]],[11,"deserialize_option","","",49,[[],["result",4]]],[11,"deserialize_unit","","",49,[[],["result",4]]],[11,"deserialize_unit_struct","","",49,[[],["result",4]]],[11,"deserialize_newtype_struct","","",49,[[],["result",4]]],[11,"deserialize_seq","","",49,[[],["result",4]]],[11,"deserialize_tuple","","",49,[[],["result",4]]],[11,"deserialize_tuple_struct","","",49,[[],["result",4]]],[11,"deserialize_map","","",49,[[],["result",4]]],[11,"deserialize_struct","","",49,[[],["result",4]]],[11,"deserialize_identifier","","",49,[[],["result",4]]],[11,"deserialize_ignored_any","","",49,[[],["result",4]]],[11,"deserialize_any","","",2,[[],["result",4]]],[11,"deserialize_bool","","",2,[[],["result",4]]],[11,"deserialize_i8","","",2,[[],["result",4]]],[11,"deserialize_i16","","",2,[[],["result",4]]],[11,"deserialize_i32","","",2,[[],["result",4]]],[11,"deserialize_i64","","",2,[[],["result",4]]],[11,"deserialize_i128","","",2,[[],["result",4]]],[11,"deserialize_u8","","",2,[[],["result",4]]],[11,"deserialize_u16","","",2,[[],["result",4]]],[11,"deserialize_u32","","",2,[[],["result",4]]],[11,"deserialize_u64","","",2,[[],["result",4]]],[11,"deserialize_u128","","",2,[[],["result",4]]],[11,"deserialize_f32","","",2,[[],["result",4]]],[11,"deserialize_f64","","",2,[[],["result",4]]],[11,"deserialize_char","","",2,[[],["result",4]]],[11,"deserialize_str","","",2,[[],["result",4]]],[11,"deserialize_string","","",2,[[],["result",4]]],[11,"deserialize_bytes","","",2,[[],["result",4]]],[11,"deserialize_byte_buf","","",2,[[],["result",4]]],[11,"deserialize_option","","",2,[[],["result",4]]],[11,"deserialize_unit","","",2,[[],["result",4]]],[11,"deserialize_unit_struct","","",2,[[],["result",4]]],[11,"deserialize_newtype_struct","","",2,[[],["result",4]]],[11,"deserialize_seq","","",2,[[],["result",4]]],[11,"deserialize_tuple","","",2,[[],["result",4]]],[11,"deserialize_tuple_struct","","",2,[[],["result",4]]],[11,"deserialize_map","","",2,[[],["result",4]]],[11,"deserialize_struct","","",2,[[],["result",4]]],[11,"deserialize_identifier","","",2,[[],["result",4]]],[11,"deserialize_ignored_any","","",2,[[],["result",4]]],[11,"deserialize_enum","","",2,[[],["result",4]]],[11,"deserialize_any","","",3,[[],["result",4]]],[11,"deserialize_bool","","",3,[[],["result",4]]],[11,"deserialize_i8","","",3,[[],["result",4]]],[11,"deserialize_i16","","",3,[[],["result",4]]],[11,"deserialize_i32","","",3,[[],["result",4]]],[11,"deserialize_i64","","",3,[[],["result",4]]],[11,"deserialize_i128","","",3,[[],["result",4]]],[11,"deserialize_u8","","",3,[[],["result",4]]],[11,"deserialize_u16","","",3,[[],["result",4]]],[11,"deserialize_u32","","",3,[[],["result",4]]],[11,"deserialize_u64","","",3,[[],["result",4]]],[11,"deserialize_u128","","",3,[[],["result",4]]],[11,"deserialize_f32","","",3,[[],["result",4]]],[11,"deserialize_f64","","",3,[[],["result",4]]],[11,"deserialize_char","","",3,[[],["result",4]]],[11,"deserialize_str","","",3,[[],["result",4]]],[11,"deserialize_string","","",3,[[],["result",4]]],[11,"deserialize_bytes","","",3,[[],["result",4]]],[11,"deserialize_byte_buf","","",3,[[],["result",4]]],[11,"deserialize_option","","",3,[[],["result",4]]],[11,"deserialize_unit","","",3,[[],["result",4]]],[11,"deserialize_unit_struct","","",3,[[],["result",4]]],[11,"deserialize_newtype_struct","","",3,[[],["result",4]]],[11,"deserialize_seq","","",3,[[],["result",4]]],[11,"deserialize_tuple","","",3,[[],["result",4]]],[11,"deserialize_tuple_struct","","",3,[[],["result",4]]],[11,"deserialize_map","","",3,[[],["result",4]]],[11,"deserialize_struct","","",3,[[],["result",4]]],[11,"deserialize_enum","","",3,[[],["result",4]]],[11,"deserialize_identifier","","",3,[[],["result",4]]],[11,"deserialize_ignored_any","","",3,[[],["result",4]]],[11,"deserialize_any","","",4,[[],["result",4]]],[11,"deserialize_bool","","",4,[[],["result",4]]],[11,"deserialize_i8","","",4,[[],["result",4]]],[11,"deserialize_i16","","",4,[[],["result",4]]],[11,"deserialize_i32","","",4,[[],["result",4]]],[11,"deserialize_i64","","",4,[[],["result",4]]],[11,"deserialize_i128","","",4,[[],["result",4]]],[11,"deserialize_u8","","",4,[[],["result",4]]],[11,"deserialize_u16","","",4,[[],["result",4]]],[11,"deserialize_u32","","",4,[[],["result",4]]],[11,"deserialize_u64","","",4,[[],["result",4]]],[11,"deserialize_u128","","",4,[[],["result",4]]],[11,"deserialize_f32","","",4,[[],["result",4]]],[11,"deserialize_f64","","",4,[[],["result",4]]],[11,"deserialize_char","","",4,[[],["result",4]]],[11,"deserialize_str","","",4,[[],["result",4]]],[11,"deserialize_string","","",4,[[],["result",4]]],[11,"deserialize_bytes","","",4,[[],["result",4]]],[11,"deserialize_byte_buf","","",4,[[],["result",4]]],[11,"deserialize_option","","",4,[[],["result",4]]],[11,"deserialize_unit","","",4,[[],["result",4]]],[11,"deserialize_unit_struct","","",4,[[],["result",4]]],[11,"deserialize_newtype_struct","","",4,[[],["result",4]]],[11,"deserialize_seq","","",4,[[],["result",4]]],[11,"deserialize_tuple","","",4,[[],["result",4]]],[11,"deserialize_tuple_struct","","",4,[[],["result",4]]],[11,"deserialize_map","","",4,[[],["result",4]]],[11,"deserialize_struct","","",4,[[],["result",4]]],[11,"deserialize_enum","","",4,[[],["result",4]]],[11,"deserialize_identifier","","",4,[[],["result",4]]],[11,"deserialize_ignored_any","","",4,[[],["result",4]]],[11,"deserialize_any","","",5,[[],["result",4]]],[11,"deserialize_seq","","",5,[[],["result",4]]],[11,"deserialize_tuple","","",5,[[],["result",4]]],[11,"deserialize_bool","","",5,[[],["result",4]]],[11,"deserialize_i8","","",5,[[],["result",4]]],[11,"deserialize_i16","","",5,[[],["result",4]]],[11,"deserialize_i32","","",5,[[],["result",4]]],[11,"deserialize_i64","","",5,[[],["result",4]]],[11,"deserialize_i128","","",5,[[],["result",4]]],[11,"deserialize_u8","","",5,[[],["result",4]]],[11,"deserialize_u16","","",5,[[],["result",4]]],[11,"deserialize_u32","","",5,[[],["result",4]]],[11,"deserialize_u64","","",5,[[],["result",4]]],[11,"deserialize_u128","","",5,[[],["result",4]]],[11,"deserialize_f32","","",5,[[],["result",4]]],[11,"deserialize_f64","","",5,[[],["result",4]]],[11,"deserialize_char","","",5,[[],["result",4]]],[11,"deserialize_str","","",5,[[],["result",4]]],[11,"deserialize_string","","",5,[[],["result",4]]],[11,"deserialize_bytes","","",5,[[],["result",4]]],[11,"deserialize_byte_buf","","",5,[[],["result",4]]],[11,"deserialize_option","","",5,[[],["result",4]]],[11,"deserialize_unit","","",5,[[],["result",4]]],[11,"deserialize_unit_struct","","",5,[[],["result",4]]],[11,"deserialize_newtype_struct","","",5,[[],["result",4]]],[11,"deserialize_tuple_struct","","",5,[[],["result",4]]],[11,"deserialize_map","","",5,[[],["result",4]]],[11,"deserialize_struct","","",5,[[],["result",4]]],[11,"deserialize_enum","","",5,[[],["result",4]]],[11,"deserialize_identifier","","",5,[[],["result",4]]],[11,"deserialize_ignored_any","","",5,[[],["result",4]]],[11,"deserialize_any","","",6,[[],["result",4]]],[11,"deserialize_enum","","",6,[[],["result",4]]],[11,"deserialize_bool","","",6,[[],["result",4]]],[11,"deserialize_i8","","",6,[[],["result",4]]],[11,"deserialize_i16","","",6,[[],["result",4]]],[11,"deserialize_i32","","",6,[[],["result",4]]],[11,"deserialize_i64","","",6,[[],["result",4]]],[11,"deserialize_i128","","",6,[[],["result",4]]],[11,"deserialize_u8","","",6,[[],["result",4]]],[11,"deserialize_u16","","",6,[[],["result",4]]],[11,"deserialize_u32","","",6,[[],["result",4]]],[11,"deserialize_u64","","",6,[[],["result",4]]],[11,"deserialize_u128","","",6,[[],["result",4]]],[11,"deserialize_f32","","",6,[[],["result",4]]],[11,"deserialize_f64","","",6,[[],["result",4]]],[11,"deserialize_char","","",6,[[],["result",4]]],[11,"deserialize_str","","",6,[[],["result",4]]],[11,"deserialize_string","","",6,[[],["result",4]]],[11,"deserialize_bytes","","",6,[[],["result",4]]],[11,"deserialize_byte_buf","","",6,[[],["result",4]]],[11,"deserialize_option","","",6,[[],["result",4]]],[11,"deserialize_unit","","",6,[[],["result",4]]],[11,"deserialize_unit_struct","","",6,[[],["result",4]]],[11,"deserialize_newtype_struct","","",6,[[],["result",4]]],[11,"deserialize_seq","","",6,[[],["result",4]]],[11,"deserialize_tuple","","",6,[[],["result",4]]],[11,"deserialize_tuple_struct","","",6,[[],["result",4]]],[11,"deserialize_map","","",6,[[],["result",4]]],[11,"deserialize_struct","","",6,[[],["result",4]]],[11,"deserialize_identifier","","",6,[[],["result",4]]],[11,"deserialize_ignored_any","","",6,[[],["result",4]]],[11,"expecting","serde::de","",28,[[["formatter",3]],["result",6]]],[11,"visit_bool","","",28,[[],["result",4]]],[11,"visit_i64","","",28,[[],["result",4]]],[11,"visit_u64","","",28,[[],["result",4]]],[11,"visit_f64","","",28,[[],["result",4]]],[11,"visit_str","","",28,[[],["result",4]]],[11,"visit_none","","",28,[[],["result",4]]],[11,"visit_some","","",28,[[],["result",4]]],[11,"visit_newtype_struct","","",28,[[],["result",4]]],[11,"visit_unit","","",28,[[],["result",4]]],[11,"visit_seq","","",28,[[],["result",4]]],[11,"visit_map","","",28,[[],["result",4]]],[11,"visit_bytes","","",28,[[],["result",4]]],[11,"visit_enum","","",28,[[],["result",4]]],[11,"next_element_seed","serde::de::value","",3,[[],[["result",4],["option",4]]]],[11,"size_hint","","",3,[[],["option",4]]],[11,"next_element_seed","","",5,[[],[["option",4],["result",4]]]],[11,"size_hint","","",5,[[],["option",4]]],[11,"next_key_seed","","",5,[[],[["option",4],["result",4]]]],[11,"next_value_seed","","",5,[[],["result",4]]],[11,"next_entry_seed","","",5,[[],[["result",4],["option",4]]]],[11,"size_hint","","",5,[[],["option",4]]],[11,"variant_seed","","",46,[[],["result",4]]],[11,"variant_seed","","",47,[[],["result",4]]],[11,"variant_seed","","",1,[[],["result",4]]],[11,"variant_seed","","",48,[[],["result",4]]],[11,"variant_seed","","",49,[[],["result",4]]],[11,"variant_seed","","",6,[[],["result",4]]],[11,"serialize_element","serde::ser","",50,[[],["result",4]]],[11,"end","","",50,[[],["result",4]]],[11,"serialize_element","","",50,[[],["result",4]]],[11,"end","","",50,[[],["result",4]]],[11,"serialize_field","","",50,[[],["result",4]]],[11,"end","","",50,[[],["result",4]]],[11,"serialize_field","","",50,[[],["result",4]]],[11,"end","","",50,[[],["result",4]]],[11,"serialize_key","","",50,[[],["result",4]]],[11,"serialize_value","","",50,[[],["result",4]]],[11,"end","","",50,[[],["result",4]]],[11,"serialize_field","","",50,[[],["result",4]]],[11,"end","","",50,[[],["result",4]]],[11,"serialize_field","","",50,[[],["result",4]]],[11,"end","","",50,[[],["result",4]]],[11,"custom","serde::de::value","",29,[[]]],[11,"custom","","",29,[[]]],[11,"clone","","",29,[[],["error",3]]],[11,"clone","","",30,[[]]],[11,"clone","","",31,[[]]],[11,"clone","","",32,[[]]],[11,"clone","","",33,[[]]],[11,"clone","","",34,[[]]],[11,"clone","","",35,[[]]],[11,"clone","","",36,[[]]],[11,"clone","","",37,[[]]],[11,"clone","","",38,[[]]],[11,"clone","","",39,[[]]],[11,"clone","","",40,[[]]],[11,"clone","","",41,[[]]],[11,"clone","","",42,[[]]],[11,"clone","","",43,[[]]],[11,"clone","","",44,[[]]],[11,"clone","","",45,[[]]],[11,"clone","","",46,[[]]],[11,"clone","","",47,[[]]],[11,"clone","","",1,[[]]],[11,"clone","","",48,[[]]],[11,"clone","","",49,[[]]],[11,"clone","","",2,[[]]],[11,"clone","","",3,[[],["seqdeserializer",3]]],[11,"clone","","",4,[[],["seqaccessdeserializer",3]]],[11,"clone","","",5,[[]]],[11,"clone","","",6,[[],["mapaccessdeserializer",3]]],[11,"clone","serde::de","",28,[[],["ignoredany",3]]],[11,"clone","","",0,[[],["unexpected",4]]],[11,"default","","",28,[[],["ignoredany",3]]],[11,"eq","serde::de::value","",29,[[["error",3]]]],[11,"ne","","",29,[[["error",3]]]],[11,"eq","serde::de","",0,[[["unexpected",4]]]],[11,"ne","","",0,[[["unexpected",4]]]],[11,"fmt","serde::de::value","",29,[[["formatter",3]],["result",6]]],[11,"fmt","","",30,[[["formatter",3]],["result",6]]],[11,"fmt","","",31,[[["formatter",3]],["result",6]]],[11,"fmt","","",32,[[["formatter",3]],["result",6]]],[11,"fmt","","",33,[[["formatter",3]],["result",6]]],[11,"fmt","","",34,[[["formatter",3]],["result",6]]],[11,"fmt","","",35,[[["formatter",3]],["result",6]]],[11,"fmt","","",36,[[["formatter",3]],["result",6]]],[11,"fmt","","",37,[[["formatter",3]],["result",6]]],[11,"fmt","","",38,[[["formatter",3]],["result",6]]],[11,"fmt","","",39,[[["formatter",3]],["result",6]]],[11,"fmt","","",40,[[["formatter",3]],["result",6]]],[11,"fmt","","",41,[[["formatter",3]],["result",6]]],[11,"fmt","","",42,[[["formatter",3]],["result",6]]],[11,"fmt","","",43,[[["formatter",3]],["result",6]]],[11,"fmt","","",44,[[["formatter",3]],["result",6]]],[11,"fmt","","",45,[[["formatter",3]],["result",6]]],[11,"fmt","","",46,[[["formatter",3]],["result",6]]],[11,"fmt","","",47,[[["formatter",3]],["result",6]]],[11,"fmt","","",1,[[["formatter",3]],["result",6]]],[11,"fmt","","",48,[[["formatter",3]],["result",6]]],[11,"fmt","","",49,[[["formatter",3]],["result",6]]],[11,"fmt","","",2,[[["formatter",3]],["result",6]]],[11,"fmt","","",3,[[["formatter",3]],["result",6]]],[11,"fmt","","",4,[[["formatter",3]],["result",6]]],[11,"fmt","","",5,[[["formatter",3]],["result",6]]],[11,"fmt","","",6,[[["formatter",3]],["result",6]]],[11,"fmt","serde::de","",28,[[["formatter",3]],["result",6]]],[11,"fmt","","",0,[[["formatter",3]],["result",6]]],[11,"fmt","serde::de::value","",29,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde::de","",0,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",8,[[["formatter",3]],["result",6]]],[11,"description","serde::de::value","",29,[[]]]],"p":[[4,"Unexpected"],[3,"BorrowedStrDeserializer"],[3,"BorrowedBytesDeserializer"],[3,"SeqDeserializer"],[3,"SeqAccessDeserializer"],[3,"MapDeserializer"],[3,"MapAccessDeserializer"],[8,"Error"],[8,"Expected"],[8,"Deserialize"],[8,"DeserializeSeed"],[8,"Deserializer"],[8,"Visitor"],[8,"SeqAccess"],[8,"MapAccess"],[8,"EnumAccess"],[8,"VariantAccess"],[8,"IntoDeserializer"],[8,"Error"],[8,"Serialize"],[8,"Serializer"],[8,"SerializeSeq"],[8,"SerializeTuple"],[8,"SerializeTupleStruct"],[8,"SerializeTupleVariant"],[8,"SerializeMap"],[8,"SerializeStruct"],[8,"SerializeStructVariant"],[3,"IgnoredAny"],[3,"Error"],[3,"UnitDeserializer"],[3,"BoolDeserializer"],[3,"I8Deserializer"],[3,"I16Deserializer"],[3,"I32Deserializer"],[3,"I64Deserializer"],[3,"IsizeDeserializer"],[3,"U8Deserializer"],[3,"U16Deserializer"],[3,"U64Deserializer"],[3,"UsizeDeserializer"],[3,"F32Deserializer"],[3,"F64Deserializer"],[3,"CharDeserializer"],[3,"I128Deserializer"],[3,"U128Deserializer"],[3,"U32Deserializer"],[3,"StrDeserializer"],[3,"StringDeserializer"],[3,"CowStrDeserializer"],[3,"Impossible"]]},\
"serde_lexpr":{"doc":"This crate provides [Serde]-based serialization and…","i":[[3,"Cons","serde_lexpr","A Lisp \\\"cons cell\\\".",null,null],[4,"Value","","Represents an S-expression value.",null,null],[13,"Nil","","The special \\\"nil\\\" value.",0,null],[13,"Null","","The empty list.",0,null],[13,"Bool","","A boolean value.",0,null],[13,"Number","","A number.",0,null],[13,"Char","","A character.",0,null],[13,"String","","A string.",0,null],[13,"Symbol","","A symbol.",0,null],[13,"Keyword","","A keyword.",0,null],[13,"Bytes","","A byte vector.",0,null],[13,"Cons","","Represents a Lisp \\\"cons cell\\\".",0,null],[13,"Vector","","A Lisp vector.",0,null],[0,"parse","","S-expression parser and options.",null,null],[3,"Parser","serde_lexpr::parse","Parser for the S-expression text representation.",null,null],[3,"Options","","Various options to influence parser behavior.",null,null],[4,"NilSymbol","","Defines the treatment of the symbol `nil`.",null,null],[13,"EmptyList","","Parse `nil` like as the empty list. This the behavior of…",1,null],[13,"Default","","Parse `nil` as a regular symbol. This is the behavior…",1,null],[13,"Special","","Parse `nil` as a special value. This allows treating the…",1,null],[4,"TSymbol","","Defines the treatment of the symbol `t`.",null,null],[13,"True","","Parse `t` as the boolean true value.",2,null],[13,"Default","","Parse `t` as a regular symbol.",2,null],[4,"Brackets","","Defines the treatment of brackets.",null,null],[13,"List","","Brackets are synonymous with regular parentheses, and…",3,null],[13,"Vector","","Brackets indicate a vector, like in Emacs Lisp.",3,null],[5,"from_reader_custom","","Parse a value from an IO stream containing a single…",null,[[["options",3]],[["value",4],["error",3],["result",4]]]],[5,"from_reader","","Parse a value from an IO stream of S-expressions, using…",null,[[],[["value",4],["error",3],["result",4]]]],[5,"from_reader_elisp","","Parse a value from an IO stream of S-expressions, using…",null,[[],[["value",4],["error",3],["result",4]]]],[5,"from_slice_custom","","Parse a value from bytes representing a single S-expression.",null,[[["options",3]],[["value",4],["error",3],["result",4]]]],[5,"from_slice","","Parse a value from bytes representing a single…",null,[[],[["value",4],["error",3],["result",4]]]],[5,"from_slice_elisp","","Parse a value from bytes representing a single…",null,[[],[["value",4],["error",3],["result",4]]]],[5,"from_str_custom","","Parse a value from a string slice representing a single…",null,[[["options",3]],[["value",4],["error",3],["result",4]]]],[5,"from_str","","Parse a value from a string slice representing a single…",null,[[],[["value",4],["error",3],["result",4]]]],[5,"from_str_elisp","","Parse a value from a string slice representing a single…",null,[[],[["value",4],["error",3],["result",4]]]],[3,"ValueIter","","Iterator over the values producedd by a parser.",null,null],[3,"DatumIter","","Iterator over the datums producedd by a parser.",null,null],[0,"error","","When parsing S-expressions goes wrong.",null,null],[3,"Error","serde_lexpr::parse::error","This type represents the possible errors when parsing…",null,null],[6,"Result","","Alias for a `Result` with the error type `lexpr::Error`.",null,null],[3,"Location","","Location of a parse error.",null,null],[4,"Category","","Categorizes the cause of a `lexpr::parse::Error`.",null,null],[13,"Io","","The error was caused by a failure to read or bytes from an…",4,null],[13,"Syntax","","The error was caused by input that was not a syntactically…",4,null],[13,"Eof","","The error was caused by prematurely reaching the end of…",4,null],[3,"Datum","serde_lexpr::parse","Combines an S-expression value with location information.",null,null],[3,"Span","","The start and end for a span of text.",null,null],[4,"CharSyntax","","Indicates the syntax for characters.",null,null],[13,"R6RS","","Syntax as specified in R6RS.",5,null],[13,"Elisp","","Emacs Lisp syntax.",5,null],[4,"KeywordSyntax","","Indicates a syntax of keywords.",null,null],[13,"ColonPrefix","","Parse identifiers starting with a colon as keywords.",6,null],[13,"ColonPostfix","","Parse identifiers ending with a colon as keywords.",6,null],[13,"Octothorpe","","Parse identifiers prefixed with `#:` as keywords.",6,null],[4,"StringSyntax","","Indicates the syntax for strings.",null,null],[13,"R6RS","","Syntax as specified the R6RS.",7,null],[13,"Elisp","","Emacs Lisp syntax.",7,null],[3,"IoRead","","S-expression input source that reads from a std::io input…",null,null],[3,"Position","","A location in the parsed text.",null,null],[8,"Read","","Trait used by the parser for iterating over input.",null,null],[11,"parse_elisp_char","","Parses an Emacs Lisp character constant.",8,[[["vec",3]],[["error",3],["result",4]]]],[3,"SliceRead","","S-expression input source that reads from a slice of bytes.",null,null],[3,"StrRead","","S-expression input source that reads from a UTF-8 string.",null,null],[3,"Error","","This type represents the possible errors when parsing…",null,null],[6,"Result","","Alias for a `Result` with the error type `lexpr::Error`.",null,null],[0,"print","serde_lexpr","Converting S-expression values into text.",null,null],[3,"Options","serde_lexpr::print","Options for printing S-expressions.",null,null],[4,"NilSyntax","","How to print the special nil value.",null,null],[13,"Symbol","","Output a `nil` symbol.",9,null],[13,"Token","","Output the `#nil` token.",9,null],[13,"EmptyList","","Output the empty list.",9,null],[13,"False","","Output a boolean false value.",9,null],[4,"BoolSyntax","","How to print boolean values.",null,null],[13,"Token","","Use the Scheme tokens `#t` and `#f`",10,null],[13,"Symbol","","Use symbols `nil` and `t`.",10,null],[4,"VectorSyntax","","How to print vectors.",null,null],[13,"Octothorpe","","Use Scheme notation, i.e. `#(...)`.",11,null],[13,"Brackets","","Use brackets, as used in Emacs Lisp.",11,null],[4,"BytesSyntax","","How to print byte vectors.",null,null],[13,"R6RS","","Use R6RS byte vector syntax, e.g. `#vu8(1 2 3)`.",12,null],[13,"R7RS","","Use R7RS byte vector syntax, e.g. `#u8(1 2 3)`.",12,null],[13,"Elisp","","Use Emacs Lisp unibyte string syntax, e.g. `\\\"\\\\001\\\\002\\\\003\\\"`.",12,null],[4,"CharEscape","","Represents a character escape code in a type-safe manner.",null,null],[13,"Quote","","An escaped quote `\\\"`",13,null],[13,"ReverseSolidus","","An escaped reverse solidus `\\\\`",13,null],[13,"Alert","","Alert, also known as \\\"bell\\\" (usually escaped as `\\\\a`)",13,null],[13,"Backspace","","An escaped backspace character (usually escaped as `\\\\b`)",13,null],[13,"LineFeed","","An escaped line feed character (usually escaped as `\\\\n`)",13,null],[13,"CarriageReturn","","An escaped carriage return character (usually escaped as…",13,null],[13,"Tab","","An escaped tab character (usually escaped as `\\\\t`)",13,null],[13,"AsciiControl","","An escaped ASCII plane control character (usually escaped…",13,null],[4,"VectorType","","Different vector types",null,null],[13,"Generic","","Generic vector, containing elements of any type.",14,null],[13,"Byte","","Byte vector, containing only byte (octet) values.",14,null],[8,"Formatter","","This trait abstracts away serializing the S-expression…",null,null],[11,"write_nil","","Writes a representation of the special nil value to the…",15,[[],[["result",4],["error",3]]]],[11,"write_null","","Writes a representation of the special nil value to the…",15,[[],[["result",4],["error",3]]]],[11,"write_bool","","Writes a representation of a boolean value to the…",15,[[],[["result",4],["error",3]]]],[11,"write_number","","Writes an integer value like `-123` to the specified writer.",15,[[["number",3]],[["result",4],["error",3]]]],[11,"write_char","","Writes a charactor to the specified writer.",15,[[],[["result",4],["error",3]]]],[11,"begin_string","","Called before each series of `write_string_fragment` and…",15,[[],[["result",4],["error",3]]]],[11,"end_string","","Called after each series of `write_string_fragment` and…",15,[[],[["result",4],["error",3]]]],[11,"write_string_fragment","","Writes a string fragment that doesn\'t need any escaping to…",15,[[],[["result",4],["error",3]]]],[11,"write_char_escape","","Writes a character escape code to the specified writer.",15,[[["charescape",4]],[["result",4],["error",3]]]],[11,"write_symbol","","Writes a symbol to the specified writer.",15,[[],[["result",4],["error",3]]]],[11,"write_keyword","","Writes a keyword to the specified writer.",15,[[],[["result",4],["error",3]]]],[11,"write_bytes","","Writes a byte vector to the specified writer.",15,[[],[["result",4],["error",3]]]],[11,"begin_list","","Called before any list elements. Writes a `(` to the…",15,[[],[["result",4],["error",3]]]],[11,"end_list","","Called after all list elements have been written. Writes a…",15,[[],[["result",4],["error",3]]]],[11,"begin_seq_element","","Called before starting to write a list or vector element.…",15,[[],[["result",4],["error",3]]]],[11,"end_seq_element","","Called after every list or vector element.",15,[[],[["result",4],["error",3]]]],[11,"begin_vector","","Called before any vector elements. Will write `#(` for…",15,[[["vectortype",4]],[["result",4],["error",3]]]],[11,"end_vector","","Called after all vector elements have been written. Writes…",15,[[],[["result",4],["error",3]]]],[11,"write_dot","","Called before writing the tail of an improper list, or…",15,[[],[["result",4],["error",3]]]],[3,"DefaultFormatter","","This structure compacts a S-expression value on a single…",null,null],[3,"CustomizedFormatter","","A formatter which can be tuned with regards to…",null,null],[3,"Printer","","A printer for S-expression values.",null,null],[5,"to_writer","","Serialize the given value value as S-expression text into…",null,[[["value",4]],[["result",4],["error",3]]]],[5,"to_writer_custom","","Serialize the given value value as S-expression text into…",null,[[["value",4],["options",3]],[["result",4],["error",3]]]],[5,"to_vec","","Serialize the given value as byte vector containing…",null,[[["value",4]],[["result",4],["vec",3],["error",3]]]],[5,"to_vec_custom","","Serialize the given value as byte vector containing…",null,[[["value",4],["options",3]],[["result",4],["vec",3],["error",3]]]],[5,"to_string","","Serialize the given value an S-expression string, using…",null,[[["value",4]],[["string",3],["error",3],["result",4]]]],[5,"to_string_custom","","Serialize the given value an S-expression string.",null,[[["value",4],["options",3]],[["string",3],["error",3],["result",4]]]],[4,"CharSyntax","","Indicates the syntax for characters.",null,null],[13,"R6RS","","Syntax as specified in R6RS.",5,null],[13,"Elisp","","Emacs Lisp syntax.",5,null],[4,"KeywordSyntax","","Indicates a syntax of keywords.",null,null],[13,"ColonPrefix","","Parse identifiers starting with a colon as keywords.",6,null],[13,"ColonPostfix","","Parse identifiers ending with a colon as keywords.",6,null],[13,"Octothorpe","","Parse identifiers prefixed with `#:` as keywords.",6,null],[4,"StringSyntax","","Indicates the syntax for strings.",null,null],[13,"R6RS","","Syntax as specified the R6RS.",7,null],[13,"Elisp","","Emacs Lisp syntax.",7,null],[5,"from_reader","serde_lexpr","Parse a value from an input stream of S-expressions, using…",null,[[],["result",6]]],[5,"from_reader_custom","","Parse a value from an input stream of S-expressions, using…",null,[[["options",3]],["result",6]]],[5,"from_slice","","Deserialize an instance of type `T` from an S-expression…",null,[[],["result",6]]],[5,"from_slice_custom","","Deserialize an instance of type `T` from an S-expression…",null,[[["options",3]],["result",6]]],[5,"from_str","","Deserialize an instance of type `T` from an S-expression…",null,[[],["result",6]]],[5,"from_str_custom","","Deserialize an instance of type `T` from an S-expression…",null,[[["options",3]],["result",6]]],[5,"to_string","","Serialize an instance of type `T` into an S-expression…",null,[[],[["string",3],["result",6]]]],[5,"to_string_custom","","Serialize an instance of type `T` into an S-expression…",null,[[["options",3]],[["string",3],["result",6]]]],[5,"to_vec","","Serialize an instance of type `T` into an S-expression…",null,[[],[["vec",3],["result",6]]]],[5,"to_vec_custom","","Serialize an instance of type `T` into an S-expression…",null,[[["options",3]],[["vec",3],["result",6]]]],[5,"to_writer","","Serialize an instance of type `T` into an S-expression…",null,[[],["result",6]]],[5,"to_writer_custom","","Serialize an instance of type `T` into an S-expression…",null,[[["options",3]],["result",6]]],[5,"from_value","","Interpret a `lexpr::Value` as an instance of type `T`.",null,[[["value",4]],["result",6]]],[5,"to_value","","Convert a `T` into `lexpr::Value` which is an enum that…",null,[[],[["result",6],["value",4]]]],[0,"error","","When serializing or deserializing S-expressions goes wrong.",null,null],[3,"Location","serde_lexpr::error","Location of a parse error.",null,null],[3,"Error","","This type represents all possible errors that can occur…",null,null],[4,"Category","","Categorizes the cause of a `serde_lexpr::Error`.",null,null],[13,"Io","","The error was caused by a failure to read or bytes from an…",16,null],[13,"Syntax","","The error was caused by input that was not a syntactically…",16,null],[13,"Data","","The error was caused by input data that was semantically…",16,null],[13,"Eof","","The error was caused by prematurely reaching the end of…",16,null],[6,"Result","","Alias for a `Result` with the error type…",null,null],[11,"location","","Location of the error in the input stream.",17,[[],[["option",4],["location",3]]]],[11,"classify","","Categorizes the cause of this error.",17,[[],["category",4]]],[11,"from","serde_lexpr","",18,[[]]],[11,"into","","",18,[[]]],[11,"into_iter","","",18,[[]]],[11,"to_owned","","",18,[[]]],[11,"clone_into","","",18,[[]]],[11,"borrow","","",18,[[]]],[11,"try_from","","",18,[[],["result",4]]],[11,"try_into","","",18,[[],["result",4]]],[11,"borrow_mut","","",18,[[]]],[11,"type_id","","",18,[[],["typeid",3]]],[11,"from","","",0,[[]]],[11,"into","","",0,[[]]],[11,"to_owned","","",0,[[]]],[11,"clone_into","","",0,[[]]],[11,"to_string","","",0,[[],["string",3]]],[11,"borrow","","",0,[[]]],[11,"try_from","","",0,[[],["result",4]]],[11,"try_into","","",0,[[],["result",4]]],[11,"borrow_mut","","",0,[[]]],[11,"type_id","","",0,[[],["typeid",3]]],[11,"from","serde_lexpr::parse","",19,[[]]],[11,"into","","",19,[[]]],[11,"into_iter","","",19,[[]]],[11,"borrow","","",19,[[]]],[11,"try_from","","",19,[[],["result",4]]],[11,"try_into","","",19,[[],["result",4]]],[11,"borrow_mut","","",19,[[]]],[11,"type_id","","",19,[[],["typeid",3]]],[11,"from","","",20,[[]]],[11,"into","","",20,[[]]],[11,"to_owned","","",20,[[]]],[11,"clone_into","","",20,[[]]],[11,"borrow","","",20,[[]]],[11,"try_from","","",20,[[],["result",4]]],[11,"try_into","","",20,[[],["result",4]]],[11,"borrow_mut","","",20,[[]]],[11,"type_id","","",20,[[],["typeid",3]]],[11,"from","","",1,[[]]],[11,"into","","",1,[[]]],[11,"to_owned","","",1,[[]]],[11,"clone_into","","",1,[[]]],[11,"borrow","","",1,[[]]],[11,"try_from","","",1,[[],["result",4]]],[11,"try_into","","",1,[[],["result",4]]],[11,"borrow_mut","","",1,[[]]],[11,"type_id","","",1,[[],["typeid",3]]],[11,"from","","",2,[[]]],[11,"into","","",2,[[]]],[11,"to_owned","","",2,[[]]],[11,"clone_into","","",2,[[]]],[11,"borrow","","",2,[[]]],[11,"try_from","","",2,[[],["result",4]]],[11,"try_into","","",2,[[],["result",4]]],[11,"borrow_mut","","",2,[[]]],[11,"type_id","","",2,[[],["typeid",3]]],[11,"from","","",3,[[]]],[11,"into","","",3,[[]]],[11,"to_owned","","",3,[[]]],[11,"clone_into","","",3,[[]]],[11,"borrow","","",3,[[]]],[11,"try_from","","",3,[[],["result",4]]],[11,"try_into","","",3,[[],["result",4]]],[11,"borrow_mut","","",3,[[]]],[11,"type_id","","",3,[[],["typeid",3]]],[11,"from","","",21,[[]]],[11,"into","","",21,[[]]],[11,"into_iter","","",21,[[]]],[11,"borrow","","",21,[[]]],[11,"try_from","","",21,[[],["result",4]]],[11,"try_into","","",21,[[],["result",4]]],[11,"borrow_mut","","",21,[[]]],[11,"type_id","","",21,[[],["typeid",3]]],[11,"from","","",22,[[]]],[11,"into","","",22,[[]]],[11,"into_iter","","",22,[[]]],[11,"borrow","","",22,[[]]],[11,"try_from","","",22,[[],["result",4]]],[11,"try_into","","",22,[[],["result",4]]],[11,"borrow_mut","","",22,[[]]],[11,"type_id","","",22,[[],["typeid",3]]],[11,"from","","",23,[[]]],[11,"into","","",23,[[]]],[11,"to_string","","",23,[[],["string",3]]],[11,"borrow","","",23,[[]]],[11,"try_from","","",23,[[],["result",4]]],[11,"try_into","","",23,[[],["result",4]]],[11,"borrow_mut","","",23,[[]]],[11,"type_id","","",23,[[],["typeid",3]]],[11,"from","serde_lexpr::error","",24,[[]]],[11,"into","","",24,[[]]],[11,"to_owned","","",24,[[]]],[11,"clone_into","","",24,[[]]],[11,"borrow","","",24,[[]]],[11,"try_from","","",24,[[],["result",4]]],[11,"try_into","","",24,[[],["result",4]]],[11,"borrow_mut","","",24,[[]]],[11,"type_id","","",24,[[],["typeid",3]]],[11,"from","serde_lexpr::parse::error","",4,[[]]],[11,"into","","",4,[[]]],[11,"to_owned","","",4,[[]]],[11,"clone_into","","",4,[[]]],[11,"borrow","","",4,[[]]],[11,"try_from","","",4,[[],["result",4]]],[11,"try_into","","",4,[[],["result",4]]],[11,"borrow_mut","","",4,[[]]],[11,"type_id","","",4,[[],["typeid",3]]],[11,"from","serde_lexpr::parse","",25,[[]]],[11,"into","","",25,[[]]],[11,"to_owned","","",25,[[]]],[11,"clone_into","","",25,[[]]],[11,"borrow","","",25,[[]]],[11,"try_from","","",25,[[],["result",4]]],[11,"try_into","","",25,[[],["result",4]]],[11,"borrow_mut","","",25,[[]]],[11,"type_id","","",25,[[],["typeid",3]]],[11,"from","","",26,[[]]],[11,"into","","",26,[[]]],[11,"to_owned","","",26,[[]]],[11,"clone_into","","",26,[[]]],[11,"borrow","","",26,[[]]],[11,"try_from","","",26,[[],["result",4]]],[11,"try_into","","",26,[[],["result",4]]],[11,"borrow_mut","","",26,[[]]],[11,"type_id","","",26,[[],["typeid",3]]],[11,"from","serde_lexpr::print","",5,[[]]],[11,"into","","",5,[[]]],[11,"to_owned","","",5,[[]]],[11,"clone_into","","",5,[[]]],[11,"borrow","","",5,[[]]],[11,"try_from","","",5,[[],["result",4]]],[11,"try_into","","",5,[[],["result",4]]],[11,"borrow_mut","","",5,[[]]],[11,"type_id","","",5,[[],["typeid",3]]],[11,"from","","",6,[[]]],[11,"into","","",6,[[]]],[11,"to_owned","","",6,[[]]],[11,"clone_into","","",6,[[]]],[11,"borrow","","",6,[[]]],[11,"try_from","","",6,[[],["result",4]]],[11,"try_into","","",6,[[],["result",4]]],[11,"borrow_mut","","",6,[[]]],[11,"type_id","","",6,[[],["typeid",3]]],[11,"from","","",7,[[]]],[11,"into","","",7,[[]]],[11,"to_owned","","",7,[[]]],[11,"clone_into","","",7,[[]]],[11,"borrow","","",7,[[]]],[11,"try_from","","",7,[[],["result",4]]],[11,"try_into","","",7,[[],["result",4]]],[11,"borrow_mut","","",7,[[]]],[11,"type_id","","",7,[[],["typeid",3]]],[11,"from","serde_lexpr::parse","",27,[[]]],[11,"into","","",27,[[]]],[11,"borrow","","",27,[[]]],[11,"try_from","","",27,[[],["result",4]]],[11,"try_into","","",27,[[],["result",4]]],[11,"borrow_mut","","",27,[[]]],[11,"type_id","","",27,[[],["typeid",3]]],[11,"from","","",28,[[]]],[11,"into","","",28,[[]]],[11,"to_owned","","",28,[[]]],[11,"clone_into","","",28,[[]]],[11,"borrow","","",28,[[]]],[11,"try_from","","",28,[[],["result",4]]],[11,"try_into","","",28,[[],["result",4]]],[11,"borrow_mut","","",28,[[]]],[11,"type_id","","",28,[[],["typeid",3]]],[11,"from","","",29,[[]]],[11,"into","","",29,[[]]],[11,"borrow","","",29,[[]]],[11,"try_from","","",29,[[],["result",4]]],[11,"try_into","","",29,[[],["result",4]]],[11,"borrow_mut","","",29,[[]]],[11,"type_id","","",29,[[],["typeid",3]]],[11,"from","","",30,[[]]],[11,"into","","",30,[[]]],[11,"borrow","","",30,[[]]],[11,"try_from","","",30,[[],["result",4]]],[11,"try_into","","",30,[[],["result",4]]],[11,"borrow_mut","","",30,[[]]],[11,"type_id","","",30,[[],["typeid",3]]],[11,"from","serde_lexpr::print","",31,[[]]],[11,"into","","",31,[[]]],[11,"to_owned","","",31,[[]]],[11,"clone_into","","",31,[[]]],[11,"borrow","","",31,[[]]],[11,"try_from","","",31,[[],["result",4]]],[11,"try_into","","",31,[[],["result",4]]],[11,"borrow_mut","","",31,[[]]],[11,"type_id","","",31,[[],["typeid",3]]],[11,"from","","",9,[[]]],[11,"into","","",9,[[]]],[11,"to_owned","","",9,[[]]],[11,"clone_into","","",9,[[]]],[11,"borrow","","",9,[[]]],[11,"try_from","","",9,[[],["result",4]]],[11,"try_into","","",9,[[],["result",4]]],[11,"borrow_mut","","",9,[[]]],[11,"type_id","","",9,[[],["typeid",3]]],[11,"from","","",10,[[]]],[11,"into","","",10,[[]]],[11,"to_owned","","",10,[[]]],[11,"clone_into","","",10,[[]]],[11,"borrow","","",10,[[]]],[11,"try_from","","",10,[[],["result",4]]],[11,"try_into","","",10,[[],["result",4]]],[11,"borrow_mut","","",10,[[]]],[11,"type_id","","",10,[[],["typeid",3]]],[11,"from","","",11,[[]]],[11,"into","","",11,[[]]],[11,"to_owned","","",11,[[]]],[11,"clone_into","","",11,[[]]],[11,"borrow","","",11,[[]]],[11,"try_from","","",11,[[],["result",4]]],[11,"try_into","","",11,[[],["result",4]]],[11,"borrow_mut","","",11,[[]]],[11,"type_id","","",11,[[],["typeid",3]]],[11,"from","","",12,[[]]],[11,"into","","",12,[[]]],[11,"to_owned","","",12,[[]]],[11,"clone_into","","",12,[[]]],[11,"borrow","","",12,[[]]],[11,"try_from","","",12,[[],["result",4]]],[11,"try_into","","",12,[[],["result",4]]],[11,"borrow_mut","","",12,[[]]],[11,"type_id","","",12,[[],["typeid",3]]],[11,"from","","",13,[[]]],[11,"into","","",13,[[]]],[11,"borrow","","",13,[[]]],[11,"try_from","","",13,[[],["result",4]]],[11,"try_into","","",13,[[],["result",4]]],[11,"borrow_mut","","",13,[[]]],[11,"type_id","","",13,[[],["typeid",3]]],[11,"from","","",14,[[]]],[11,"into","","",14,[[]]],[11,"borrow","","",14,[[]]],[11,"try_from","","",14,[[],["result",4]]],[11,"try_into","","",14,[[],["result",4]]],[11,"borrow_mut","","",14,[[]]],[11,"type_id","","",14,[[],["typeid",3]]],[11,"from","","",32,[[]]],[11,"into","","",32,[[]]],[11,"to_owned","","",32,[[]]],[11,"clone_into","","",32,[[]]],[11,"borrow","","",32,[[]]],[11,"try_from","","",32,[[],["result",4]]],[11,"try_into","","",32,[[],["result",4]]],[11,"borrow_mut","","",32,[[]]],[11,"type_id","","",32,[[],["typeid",3]]],[11,"from","","",33,[[]]],[11,"into","","",33,[[]]],[11,"to_owned","","",33,[[]]],[11,"clone_into","","",33,[[]]],[11,"borrow","","",33,[[]]],[11,"try_from","","",33,[[],["result",4]]],[11,"try_into","","",33,[[],["result",4]]],[11,"borrow_mut","","",33,[[]]],[11,"type_id","","",33,[[],["typeid",3]]],[11,"from","","",34,[[]]],[11,"into","","",34,[[]]],[11,"borrow","","",34,[[]]],[11,"try_from","","",34,[[],["result",4]]],[11,"try_into","","",34,[[],["result",4]]],[11,"borrow_mut","","",34,[[]]],[11,"type_id","","",34,[[],["typeid",3]]],[11,"from","serde_lexpr::error","",17,[[]]],[11,"into","","",17,[[]]],[11,"to_string","","",17,[[],["string",3]]],[11,"borrow","","",17,[[]]],[11,"try_from","","",17,[[],["result",4]]],[11,"try_into","","",17,[[],["result",4]]],[11,"borrow_mut","","",17,[[]]],[11,"type_id","","",17,[[],["typeid",3]]],[11,"from","","",16,[[]]],[11,"into","","",16,[[]]],[11,"to_owned","","",16,[[]]],[11,"clone_into","","",16,[[]]],[11,"borrow","","",16,[[]]],[11,"try_from","","",16,[[],["result",4]]],[11,"try_into","","",16,[[],["result",4]]],[11,"borrow_mut","","",16,[[]]],[11,"type_id","","",16,[[],["typeid",3]]],[11,"fmt","serde_lexpr::parse","",3,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",32,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",2,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse::error","",4,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",20,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",10,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",6,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr","",18,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",9,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",25,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",7,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::error","",24,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",11,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",31,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","","",12,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",23,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",34,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",28,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",33,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",1,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::print","",5,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr","",0,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",26,[[["formatter",3]],[["error",3],["result",4]]]],[11,"default","serde_lexpr::print","",31,[[],["options",3]]],[11,"default","serde_lexpr::parse","Construct a default set of options. This corresponds most…",20,[[],["options",3]]],[11,"partial_cmp","","",28,[[["position",3]],[["option",4],["ordering",4]]]],[11,"lt","","",28,[[["position",3]]]],[11,"le","","",28,[[["position",3]]]],[11,"gt","","",28,[[["position",3]]]],[11,"ge","","",28,[[["position",3]]]],[11,"from_str","serde_lexpr","",0,[[],[["value",4],["result",4]]]],[11,"source","serde_lexpr::parse","",23,[[],[["option",4],["error",8]]]],[11,"next","","",19,[[],["option",4]]],[11,"next","","",22,[[],["option",4]]],[11,"next","","",21,[[],["option",4]]],[11,"clone","","",2,[[],["tsymbol",4]]],[11,"clone","serde_lexpr::print","",31,[[],["options",3]]],[11,"clone","serde_lexpr","",0,[[],["value",4]]],[11,"clone","serde_lexpr::print","",6,[[],["keywordsyntax",4]]],[11,"clone","serde_lexpr::parse","",28,[[],["position",3]]],[11,"clone","serde_lexpr::print","",10,[[],["boolsyntax",4]]],[11,"clone","","",11,[[],["vectorsyntax",4]]],[11,"clone","serde_lexpr::parse","",25,[[],["datum",3]]],[11,"clone","serde_lexpr::error","",24,[[],["location",3]]],[11,"clone","serde_lexpr::print","",5,[[],["charsyntax",4]]],[11,"clone","","",32,[[],["defaultformatter",3]]],[11,"clone","serde_lexpr::parse::error","",4,[[],["category",4]]],[11,"clone","serde_lexpr::parse","",1,[[],["nilsymbol",4]]],[11,"clone","serde_lexpr","",18,[[],["cons",3]]],[11,"clone","serde_lexpr::parse","",3,[[],["brackets",4]]],[11,"clone","serde_lexpr::print","",9,[[],["nilsyntax",4]]],[11,"clone","serde_lexpr::parse","",26,[[],["span",3]]],[11,"clone","serde_lexpr::print","",33,[[],["customizedformatter",3]]],[11,"clone","serde_lexpr::parse","",20,[[],["options",3]]],[11,"clone","serde_lexpr::print","",12,[[],["bytessyntax",4]]],[11,"clone","","",7,[[],["stringsyntax",4]]],[11,"index_into","serde_lexpr","",0,[[["value",4]],[["value",4],["option",4]]]],[11,"fmt","","Display an S-expression value as a string.",0,[[["formatter",3]],[["error",3],["result",4]]]],[11,"fmt","serde_lexpr::parse","",23,[[["formatter",3]],[["error",3],["result",4]]]],[11,"into_iter","serde_lexpr","Obtains an iterator yielding the contents of the elements…",18,[[],["intoiter",3]]],[11,"hash","serde_lexpr::parse","",26,[[]]],[11,"hash","","",28,[[]]],[11,"write_nil","serde_lexpr::print","",33,[[],[["result",4],["error",3]]]],[11,"write_bool","","",33,[[],[["result",4],["error",3]]]],[11,"write_keyword","","",33,[[],[["result",4],["error",3]]]],[11,"begin_vector","","",33,[[["vectortype",4]],[["result",4],["error",3]]]],[11,"end_vector","","",33,[[],[["result",4],["error",3]]]],[11,"write_char","","",33,[[],[["result",4],["error",3]]]],[11,"write_char_escape","","Writes a character escape code to the specified writer.",33,[[["charescape",4]],[["result",4],["error",3]]]],[11,"write_bytes","","",33,[[],[["result",4],["error",3]]]],[11,"write","","",34,[[],[["result",4],["error",3]]]],[11,"flush","","",34,[[],[["result",4],["error",3]]]],[11,"index","serde_lexpr","Index into a `lexpr::Value` using the syntax `value[0]` or…",0,[[],["value",4]]],[11,"next","serde_lexpr::parse","",29,[[],[["option",4],["error",3],["result",4]]]],[11,"peek","","",29,[[],[["option",4],["error",3],["result",4]]]],[11,"discard","","",29,[[]]],[11,"position","","",29,[[],["position",3]]],[11,"peek_position","","",29,[[],["position",3]]],[11,"byte_offset","","",29,[[]]],[11,"parse_r6rs_str","","",29,[[["vec",3]],[["result",4],["reference",4],["error",3]]]],[11,"parse_elisp_str","","",29,[[["vec",3]],[["elispstr",4],["error",3],["result",4]]]],[11,"parse_symbol","","",29,[[["vec",3]],[["result",4],["reference",4],["error",3]]]],[11,"next","","",27,[[],[["option",4],["error",3],["result",4]]]],[11,"peek","","",27,[[],[["option",4],["error",3],["result",4]]]],[11,"discard","","",27,[[]]],[11,"position","","",27,[[],["position",3]]],[11,"peek_position","","",27,[[],["position",3]]],[11,"byte_offset","","",27,[[]]],[11,"parse_r6rs_str","","",27,[[["vec",3]],[["error",3],["result",4],["reference",4]]]],[11,"parse_elisp_str","","",27,[[["vec",3]],[["elispstr",4],["error",3],["result",4]]]],[11,"parse_symbol","","",27,[[["vec",3]],[["error",3],["result",4],["reference",4]]]],[11,"next","","",30,[[],[["option",4],["error",3],["result",4]]]],[11,"peek","","",30,[[],[["option",4],["error",3],["result",4]]]],[11,"discard","","",30,[[]]],[11,"position","","",30,[[],["position",3]]],[11,"peek_position","","",30,[[],["position",3]]],[11,"byte_offset","","",30,[[]]],[11,"parse_r6rs_str","","",30,[[["vec",3]],[["result",4],["reference",4],["error",3]]]],[11,"parse_elisp_str","","",30,[[["vec",3]],[["elispstr",4],["error",3],["result",4]]]],[11,"parse_symbol","","",30,[[["vec",3]],[["result",4],["reference",4],["error",3]]]],[11,"eq","serde_lexpr","",18,[[["cons",3]]]],[11,"ne","","",18,[[["cons",3]]]],[11,"eq","serde_lexpr::parse","",2,[[["tsymbol",4]]]],[11,"eq","serde_lexpr::print","",6,[[["keywordsyntax",4]]]],[11,"eq","serde_lexpr::parse::error","",4,[[["category",4]]]],[11,"eq","serde_lexpr::parse","",3,[[["brackets",4]]]],[11,"eq","serde_lexpr","",0,[[]]],[11,"eq","serde_lexpr::parse","",26,[[["span",3]]]],[11,"ne","","",26,[[["span",3]]]],[11,"eq","serde_lexpr","",0,[[]]],[11,"eq","serde_lexpr::parse","",25,[[["datum",3]]]],[11,"ne","","",25,[[["datum",3]]]],[11,"eq","serde_lexpr","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","serde_lexpr::parse","",1,[[["nilsymbol",4]]]],[11,"eq","serde_lexpr","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[["value",4]]]],[11,"ne","","",0,[[["value",4]]]],[11,"eq","","",0,[[]]],[11,"eq","","",0,[[]]],[11,"eq","serde_lexpr::print","",5,[[["charsyntax",4]]]],[11,"eq","serde_lexpr","",0,[[["string",3]]]],[11,"eq","","",0,[[]]],[11,"eq","serde_lexpr::parse","",28,[[["position",3]]]],[11,"ne","","",28,[[["position",3]]]],[11,"eq","serde_lexpr","",0,[[]]],[11,"eq","serde_lexpr::print","",7,[[["stringsyntax",4]]]],[11,"eq","serde_lexpr","",0,[[]]],[11,"eq","serde_lexpr::error","",24,[[["location",3]]]],[11,"ne","","",24,[[["location",3]]]],[11,"from","serde_lexpr","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[["box",3]],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[["box",3]],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[["number",3]],["value",4]]],[11,"from","","",0,[[["cow",4]],["value",4]]],[11,"from","","",0,[[["vec",3],["value",4]],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","serde_lexpr::parse","Turns a reference into an owned `Datum`, by cloning the…",25,[[["ref",3]],["datum",3]]],[11,"from","serde_lexpr","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[["vec",3]],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[["box",3]],["value",4]]],[11,"from","","",0,[[["string",3]],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[],["value",4]]],[11,"from","","",0,[[["cons",3]],["value",4]]],[11,"from","","",0,[[["datum",3]],["value",4]]],[11,"cmp","serde_lexpr::parse","",28,[[["position",3]],["ordering",4]]],[11,"from","serde_lexpr::error","",17,[[["error",3]]]],[11,"from","","",17,[[["error",3]]]],[11,"clone","","",16,[[],["category",4]]],[11,"eq","","",16,[[["category",4]]]],[11,"fmt","","",16,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"fmt","","",17,[[["formatter",3]],["result",6]]],[11,"source","","",17,[[],[["option",4],["error",8]]]],[11,"custom","","",17,[[["display",8]],["error",3]]],[11,"custom","","",17,[[["display",8]],["error",3]]],[11,"invalid_type","","",17,[[["expected",8],["unexpected",4]]]],[11,"new","serde_lexpr","Constructs a new cons cell from two values.",18,[[],["cons",3]]],[11,"car","","Returns a reference to the value in the `car` field.",18,[[],["value",4]]],[11,"car_mut","","Returns a mutable reference to the value in the `car` field.",18,[[],["value",4]]],[11,"set_car","","Sets the `car` field.",18,[[]]],[11,"cdr","","Returns a reference to the value in the `cdr` field.",18,[[],["value",4]]],[11,"cdr_mut","","Returns a mutable reference to the value in the `cdr` field.",18,[[],["value",4]]],[11,"set_cdr","","Sets the `cdr` field.",18,[[]]],[11,"as_pair","","Returns references to the values in the `car` and `cdr`…",18,[[]]],[11,"into_pair","","Converts `self` into a pair of values without cloning.",18,[[]]],[11,"iter","","Obtains an iterator yielding references to all the cons…",18,[[],["iter",3]]],[11,"into_vec","","Converts `self` into a vector without cloning the elements.",18,[[]]],[11,"to_vec","","Retrieves a vector, cloning the values.",18,[[]]],[11,"to_ref_vec","","Retrieves a vector, taking references to the values.",18,[[]]],[11,"list_iter","","Returns an iterator that returns each element (`car`…",18,[[],["listiter",3]]],[11,"symbol","","Construct a symbol, given its name.",0,[[],["value",4]]],[11,"keyword","","Construct a keyword, given its name.",0,[[],["value",4]]],[11,"string","","Construct a string.",0,[[],["value",4]]],[11,"bytes","","Construct a byte vector.",0,[[],["value",4]]],[11,"cons","","Create a cons cell given its `car` and `cdr` fields.",0,[[],["value",4]]],[11,"list","","Create a list value from elements convertible into `Value`.",0,[[],["value",4]]],[11,"is_list","","Returns true if the value is a (proper) list.",0,[[]]],[11,"is_dotted_list","","Returns true if the value is a dotted (improper) list.",0,[[]]],[11,"append","","Create a list value from elements convertible into…",0,[[],["value",4]]],[11,"vector","","Create a vector value from elements convertible into…",0,[[],["value",4]]],[11,"is_string","","Returns true if the value is a String. Returns false…",0,[[]]],[11,"as_str","","If the value is a String, returns the associated str.…",0,[[],["option",4]]],[11,"is_symbol","","Returns true if the value is a symbol. Returns false…",0,[[]]],[11,"as_symbol","","If the value is a symbol, returns the associated str.…",0,[[],["option",4]]],[11,"is_keyword","","Returns true if the value is a keyword. Returns false…",0,[[]]],[11,"as_keyword","","If the value is a keyword, returns the associated str.…",0,[[],["option",4]]],[11,"as_name","","Get the name of a symbol or keyword, or the value of a…",0,[[],["option",4]]],[11,"is_bytes","","Returns true if the value is a byte vector. Returns false…",0,[[]]],[11,"as_bytes","","If the value is a byte vector, returns the associated byte…",0,[[],["option",4]]],[11,"is_number","","Return `true` if the value is a number.",0,[[]]],[11,"as_number","","For numbers, return a reference to them. For other values,…",0,[[],[["number",3],["option",4]]]],[11,"is_i64","","Returns true if the value is an integer between `i64::MIN`…",0,[[]]],[11,"is_u64","","Returns true if the value is an integer between zero and…",0,[[]]],[11,"is_f64","","Returns true if the value is a number that can be…",0,[[]]],[11,"as_i64","","If the value is an integer, represent it as i64 if…",0,[[],["option",4]]],[11,"as_u64","","If the value is an integer, represent it as u64 if…",0,[[],["option",4]]],[11,"as_f64","","If the value is a number, represent it as f64 if possible.…",0,[[],["option",4]]],[11,"is_boolean","","Returns true if the value is a Boolean. Returns false…",0,[[]]],[11,"as_bool","","If the value is a `Boolean`, returns the associated bool.…",0,[[],["option",4]]],[11,"is_char","","Returns true if the value is a character. Returns false…",0,[[]]],[11,"as_char","","If the value is a character, returns the associated…",0,[[],["option",4]]],[11,"is_nil","","Returns true if the value is `Nil`. Returns false otherwise.",0,[[]]],[11,"as_nil","","If the value is `Nil`, returns `()`. Returns `None`…",0,[[],["option",4]]],[11,"is_null","","Returns true if the value is `Null`. Returns false…",0,[[]]],[11,"as_null","","If the value is `Null`, returns `()`. Returns `None`…",0,[[],["option",4]]],[11,"is_cons","","Returns true if the value is a cons cell. Returns `False`…",0,[[]]],[11,"as_cons","","If the value is a cons cell, returns a reference to it.…",0,[[],[["option",4],["cons",3]]]],[11,"as_cons_mut","","If the value is a cons cell, returns a mutable reference…",0,[[],[["cons",3],["option",4]]]],[11,"as_pair","","If the value is a cons cell, return references to its…",0,[[],["option",4]]],[11,"is_vector","","Returns true if the value is a vector.",0,[[]]],[11,"as_slice","","If the value is a vector, return a reference to its…",0,[[],["option",4]]],[11,"as_slice_mut","","If the value is a vector, return a mutable reference to…",0,[[],["option",4]]],[11,"list_iter","","If the value is a list, return an iterator over the list…",0,[[],[["listiter",3],["option",4]]]],[11,"to_vec","","Attempts conversion to a vector, cloning the values.",0,[[],[["vec",3],["option",4]]]],[11,"to_ref_vec","","Attempts conversion to a vector, taking references to the…",0,[[],[["option",4],["vec",3]]]],[11,"get","","Index into a S-expression list. A string or `Value` value…",0,[[],[["value",4],["option",4]]]],[11,"new","serde_lexpr::parse","Create an S-expression parser from one of the possible…",19,[[],["parser",3]]],[11,"with_options","","Create a customized S-expression parser parser from one of…",19,[[["options",3]],["parser",3]]],[11,"from_reader","","Creates an S-expression parser from an `io::Read`.",19,[[],[["parser",3],["ioread",3]]]],[11,"from_reader_custom","","Creates an S-expression parser from an `io::Read`.",19,[[["options",3]],[["parser",3],["ioread",3]]]],[11,"from_slice","","Creates an S-expression parser from a `&[u8]`.",19,[[],[["parser",3],["sliceread",3]]]],[11,"from_slice_custom","","Creates an S-expression parser from a `&[u8]`.",19,[[["options",3]],[["parser",3],["sliceread",3]]]],[11,"from_str","","Creates a S-expression parser from a `&str`.",19,[[],[["strread",3],["parser",3]]]],[11,"from_str_custom","","Creates a S-expression parser from a `&str`.",19,[[["options",3]],[["strread",3],["parser",3]]]],[11,"expect_end","","Expect the end of input.",19,[[],[["error",3],["result",4]]]],[11,"end","","Expect the end of input.",19,[[],[["error",3],["result",4]]]],[11,"value_iter","","Obtain an iterator over the values produced by the parser.",19,[[],["valueiter",3]]],[11,"datum_iter","","Obtain an iterator over the values produced by the parser,…",19,[[],["datumiter",3]]],[11,"parse_value","","Parse a single S-expression from the input source.",19,[[],[["value",4],["error",3],["result",4]]]],[11,"expect_value","","Parse a single S-expression from the input source.",19,[[],[["value",4],["error",3],["result",4]]]],[11,"next_value","","Parse an S-expression, returning `None` on end-of-input.",19,[[],[["option",4],["result",4],["error",3]]]],[11,"parse","","Parse a single S-expression from the input source.",19,[[],[["option",4],["result",4],["error",3]]]],[11,"expect_datum","","Parse a single S-expression including location…",19,[[],[["result",4],["error",3],["datum",3]]]],[11,"next_datum","","Parse a single S-expression including location information.",19,[[],[["result",4],["error",3],["option",4]]]],[11,"new","","Construct an empty set of options.",20,[[],["options",3]]],[11,"elisp","","Construct a set of options suitable for parsing Emacs Lisp.",20,[[],["options",3]]],[11,"with_keyword_syntax","","Add `syntax` to the recognized keyword syntaxes.",20,[[["keywordsyntax",4]],["options",3]]],[11,"with_keyword_syntaxes","","Set the recognized keyword syntaxes.",20,[[],["options",3]]],[11,"with_nil_symbol","","Choose how to parse the `nil` symbol.",20,[[["nilsymbol",4]],["options",3]]],[11,"with_t_symbol","","Choose how to parse the `t` symbol.",20,[[["tsymbol",4]],["options",3]]],[11,"with_brackets","","Choose how to handle brackets.",20,[[["brackets",4]],["options",3]]],[11,"with_string_syntax","","Choose the accepted string syntax.",20,[[["stringsyntax",4]],["options",3]]],[11,"with_char_syntax","","Choose the accepted character syntax.",20,[[["charsyntax",4]],["options",3]]],[11,"keyword_syntax","","Check wether a keyword syntax is enabled.",20,[[["keywordsyntax",4]]]],[11,"nil_symbol","","Query the way the `nil` symbol is handled.",20,[[],["nilsymbol",4]]],[11,"t_symbol","","Query the way the `t` symbol is handled.",20,[[],["tsymbol",4]]],[11,"brackets","","Query the way brackets are handled.",20,[[],["brackets",4]]],[11,"string_syntax","","Query the accepted string syntax.",20,[[],["stringsyntax",4]]],[11,"char_syntax","","Query the accepted character syntax.",20,[[],["charsyntax",4]]],[11,"location","","Location of the error in the input stream.",23,[[],[["location",3],["option",4]]]],[11,"classify","","Categorizes the cause of this error.",23,[[],["category",4]]],[11,"is_io","","Returns true if this error was caused by a failure to read…",23,[[]]],[11,"is_syntax","","Returns true if this error was caused by input that was…",23,[[]]],[11,"is_eof","","Returns true if this error was caused by prematurely…",23,[[]]],[11,"line","serde_lexpr::error","One-based line number at which the error was detected.",24,[[]]],[11,"column","","One-based column number at which the error was detected.",24,[[]]],[11,"value","serde_lexpr::parse","Returns a reference to the contained value.",25,[[],["value",4]]],[11,"span","","Returns the span for the compelete value.",25,[[],["span",3]]],[11,"as_ref","","Returns a reference to the datum.",25,[[],["ref",3]]],[11,"list_iter","","Returns an iterator over the elements of a list.",25,[[],[["option",4],["listiter",3]]]],[11,"vector_iter","","Returns an iterator over the elements of a vector.",25,[[],[["vectoriter",3],["option",4]]]],[11,"start","","Get the starting line/column in the source file for this…",26,[[],["position",3]]],[11,"end","","Get the ending line/column in the source file for this span.",26,[[],["position",3]]],[11,"new","","Create a S-expression input source to read from a std::io…",27,[[],["ioread",3]]],[11,"line","","Returns the 1-based line number.",28,[[]]],[11,"column","","Returns the column.",28,[[]]],[11,"new","","Create a S-expression input source to read from a slice of…",29,[[],["sliceread",3]]],[11,"new","","Create a S-expression input source to read from a UTF-8…",30,[[],["strread",3]]],[11,"elisp","serde_lexpr::print","Construct parser options suitable for printing Emacs Lisp.",31,[[],["options",3]]],[11,"with_keyword_syntax","","Set the syntax to use for printing keywords.",31,[[["keywordsyntax",4]],["options",3]]],[11,"with_nil_syntax","","Set the syntax to use to print the special nil value.",31,[[["nilsyntax",4]],["options",3]]],[11,"with_bool_syntax","","Set the syntax to use to print boolean values.",31,[[["boolsyntax",4]],["options",3]]],[11,"with_vector_syntax","","Set the syntax for printing vectors.",31,[[["vectorsyntax",4]],["options",3]]],[11,"with_bytes_syntax","","Set the syntax to use for printing byte vectors.",31,[[["bytessyntax",4]],["options",3]]],[11,"with_string_syntax","","Set the syntax used for printing strings.",31,[[["stringsyntax",4]],["options",3]]],[11,"with_char_syntax","","Set the syntax used for printing characters.",31,[[["charsyntax",4]],["options",3]]],[11,"with_options","","Construct an S-expression printer tuned given the…",34,[[["options",3]],[["customizedformatter",3],["printer",3]]]],[11,"with_formatter","","Creates a new S-expression printer whose output will be…",34,[[],["printer",3]]],[11,"into_inner","","Unwrap the `Writer` from the `Printer`.",34,[[]]],[11,"print","","Output the representation of the specified value to the…",34,[[["value",4]],[["result",4],["error",3]]]],[11,"new","","Creates a new S-expression printer.",34,[[],[["defaultformatter",3],["printer",3]]]]],"p":[[4,"Value"],[4,"NilSymbol"],[4,"TSymbol"],[4,"Brackets"],[4,"Category"],[4,"CharSyntax"],[4,"KeywordSyntax"],[4,"StringSyntax"],[8,"Read"],[4,"NilSyntax"],[4,"BoolSyntax"],[4,"VectorSyntax"],[4,"BytesSyntax"],[4,"CharEscape"],[4,"VectorType"],[8,"Formatter"],[4,"Category"],[3,"Error"],[3,"Cons"],[3,"Parser"],[3,"Options"],[3,"ValueIter"],[3,"DatumIter"],[3,"Error"],[3,"Location"],[3,"Datum"],[3,"Span"],[3,"IoRead"],[3,"Position"],[3,"SliceRead"],[3,"StrRead"],[3,"Options"],[3,"DefaultFormatter"],[3,"CustomizedFormatter"],[3,"Printer"]]},\
"unicode_xid":{"doc":"Determine if a `char` is a valid identifier for a parser…","i":[[17,"UNICODE_VERSION","unicode_xid","The version of Unicode that this version of unicode-xid is…",null,null],[8,"UnicodeXID","","Methods for determining if a character is a valid…",null,null],[10,"is_xid_start","","Returns whether the specified character satisfies the…",0,[[]]],[10,"is_xid_continue","","Returns whether the specified `char` satisfies the…",0,[[]]]],"p":[[8,"UnicodeXID"]]}\
}');
addSearchOptions(searchIndex);initSearch(searchIndex);